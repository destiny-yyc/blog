<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>版本号的定义</title>
    <link href="/blog/version-detail.html"/>
    <url>/blog/version-detail.html</url>
    
    <content type="html"><![CDATA[<h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><p>软件版本号主要信息一般有“主版本号（Major）”、 “副版本号（Minor）”、 “微版本号（Micro）”、 “限定字符串（Qualifier）”四项。</p><p>版本号由这四项按照某种格式组装成一个字符串，格式由软件发布者或者组织自由定义，每个软件的版本定义可能都不一样，但它们都遵循一定的格式，如<code>version: 主版本号.副版本号.微版本号.build-限定字符串</code>或者<code>v主版本号.副版本号.微版本号（Build-限定字符串）</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs markdown">version: 1.2.3.build-585448或v6.1.8（Build-bc730e2e1）</code></pre></div><p>根据一般软件版本发布习惯，“主版本号（Major）” + “副版本号（Minor）” + “微版本号（Micro）” + “限定字符串（Qualifier）”有约定俗成的含义：</p><ul><li>“主版本号（Major）” ：表示与之前版本不兼容的重大功能升级。</li><li>“副版本号（Minor）” ：表示与上个版本兼容，但可能提供了新的特性或接口。</li><li>“微版本号（Micro）” ：表示API接口没有发生变化，只是程序内部实现改变，或者修正了某个错误。</li><li>“限定字符串（Qualifier）”：通常用于表示编译时间戳或编译次数等信息。</li></ul><h1 id="版本号比较"><a href="#版本号比较" class="headerlink" title="版本号比较"></a>版本号比较</h1><p>版本号是可以比较的，比较时应遵循软件版本发布的格式，解析出版本号中的“主版本号（Major）”、 “副版本号（Minor）”、 “微版本号（Micro）”、 “限定字符串（Qualifier），从前往后逐项比较。</p><p>当且仅当所有项都完全一致时表示两个版本相等，否则以第一个出现差异的版本号的大小决定整个版本号的大小。但也必须处理限定字符串的，如 Maven的版本管理中 <code>1.2.3.2022 &lt;= 1.2.3</code></p>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>version</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css 命名规范 BEM</title>
    <link href="/blog/version-detail.html"/>
    <url>/blog/version-detail.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  没有太重视“命名”这个似乎不在技术范畴之内的东西，随着项目更新迭代变得庞大，维护起来欲哭无泪。尤其是在CSS中，一个高效的命名规范到底有多重要？</p><blockquote><ul><li>代码结构更加清晰有意义</li><li>维护变得简单</li><li>同事看代码的时候不骂街了</li></ul></blockquote><p>  之前看到过一种丑丑的命名（”__”和”–”）不以为然，这正是本文探讨的主题——BEM命名规范。</p><h3 id="1-BEM简介"><a href="#1-BEM简介" class="headerlink" title="1. BEM简介"></a>1. BEM简介</h3><p>  BEM(Block Element Modifier)是由Yandex(俄罗斯的网络服务门户之一)团队提出的一种前端命名规范，这里讲的BEM风格是经过改良的（没有具体阅读过相关文章，不探讨有关如何改良的细节）：</p><blockquote><ul><li>Block：块</li><li>Element：元素——块的组成部分</li><li>Modifier：修饰符——表示一种形态&#x2F;状态</li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.block</span> &#123;&#125;<span class="hljs-selector-class">.block__element</span> &#123;&#125;<span class="hljs-selector-class">.block--modifier</span></code></pre></div><p>举一个很好理解的例子：</p><div class="code-wrapper"><pre><code class="hljs css">人            <span class="hljs-selector-id">#Block</span>人__手          <span class="hljs-selector-id">#Element</span>人__手--小手      <span class="hljs-selector-id">#Modifier</span>人__手--大手      <span class="hljs-selector-id">#Modifier</span>人__脚          <span class="hljs-selector-id">#Element</span>人--男人        <span class="hljs-selector-id">#Modifier</span>人--男人__手      <span class="hljs-selector-id">#Element</span>人--男人__脚      <span class="hljs-selector-id">#Element</span>人--女人        <span class="hljs-selector-id">#Modifier</span>人--女人__手      <span class="hljs-selector-id">#Element</span>人--女人__脚      <span class="hljs-selector-id">#Element</span></code></pre></div><h3 id="2-BEM命名-vs-传统命名"><a href="#2-BEM命名-vs-传统命名" class="headerlink" title="2. BEM命名 vs 传统命名"></a>2. BEM命名 vs 传统命名</h3><p>好与不好，代码为证：</p><h4 id="2-1-BEM命名"><a href="#2-1-BEM命名" class="headerlink" title="2.1 BEM命名"></a>2.1 BEM命名</h4><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- app.vue --&gt;&lt;aside class=&quot;aside&quot;&gt;  &lt;!-- 显示/隐藏侧边栏 --&gt;  &lt;img :class=&quot;[&#x27;aside__toggle--show&#x27;, &#123;&#x27;aside__toggle--hide&#x27;: isHide&#125;]&quot; /&gt;  &lt;ul class=&quot;aside__menu&quot;&gt;    &lt;li class=&quot;aside__menu__item&quot;&gt;首页&lt;/li&gt;  &lt;/ul&gt;&lt;/aside&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*css*/</span><span class="hljs-selector-class">.aside</span> &#123;&#125;<span class="hljs-selector-class">.aside__toggle--show</span> &#123;&#125;<span class="hljs-selector-class">.aside__toggle--hide</span> &#123;&#125;<span class="hljs-selector-class">.aside__menu</span> &#123;&#125;<span class="hljs-selector-class">.aside__menu__item</span> &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs less/scss">/*scss或less*/.aside &#123;  &amp;__toggle &#123;    &amp;--show &#123;&#125;    &amp;--hide &#123;&#125;  &#125;  &amp;__menu &#123;    &amp;__item &#123;&#125;  &#125;&#125;</code></pre></div><h4 id="2-2-传统命名"><a href="#2-2-传统命名" class="headerlink" title="2.2 传统命名"></a>2.2 传统命名</h4><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- app.vue --&gt;&lt;aside class=&quot;aside&quot;&gt;  &lt;!-- 显示/隐藏侧边栏 --&gt;  &lt;img :class=&quot;[&#x27;toggle&#x27;, &#123;&#x27;hide&#x27;: isHide&#125;]&quot; /&gt;  &lt;ul class=&quot;menu&quot;&gt;    &lt;li class=&quot;item&quot;&gt;首页&lt;/li&gt;  &lt;/ul&gt;&lt;/aside&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><span class="hljs-selector-class">.aside</span> &#123;&#125;<span class="hljs-selector-class">.toggle</span> &#123;&#125;<span class="hljs-selector-class">.menu</span> &#123;&#125;<span class="hljs-selector-class">.item</span> &#123;&#125;</code></pre></div><p>当然也有一些针对传统命名的优化，尽管看起来清晰很多，但意图的表达仍然有些不明确</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- app.vue --&gt;&lt;aside class=&quot;aside&quot;&gt;  &lt;!-- 显示/隐藏侧边栏 --&gt;  &lt;img :class=&quot;[&#x27;aside-toggle-show&#x27;, &#123;&#x27;aside-toggle-hide&#x27;: isHide&#125;]&quot; /&gt;  &lt;ul class=&quot;aside-menu&quot;&gt;    &lt;li class=&quot;aside-menu-item&quot;&gt;首页&lt;/li&gt;  &lt;/ul&gt;&lt;/aside&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*css*/</span><span class="hljs-selector-class">.aside</span> &#123;&#125;<span class="hljs-selector-class">.aside-toggle-show</span> &#123;&#125;<span class="hljs-selector-class">.aside-toggle-hide</span> &#123;&#125;<span class="hljs-selector-class">.aside-menu</span> &#123;&#125;<span class="hljs-selector-class">.aside-menu-item</span> &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss/less">/*scss或less*/.aside &#123;  &amp;-toggle &#123;    &amp;-show &#123;&#125;    &amp;-hide &#123;&#125;  &#125;  &amp;-menu &#123;    &amp;-item &#123;&#125;  &#125;</code></pre></div><p><strong>通过对比可以看到，BEM命名使得代码结构清晰多了，并且能把代码的意图表达得很明确。</strong></p><h3 id="3-正确地使用BEM"><a href="#3-正确地使用BEM" class="headerlink" title="3. 正确地使用BEM"></a>3. 正确地使用BEM</h3><p>  举一个例子，你的手里拿着一本书，但你不能说这本书是人的一部分。这就好比在代码中，有一个元素刚好某个块中，但它本身并不属于这个块，按照BEM原则，此元素的命名不该包含进去：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav__menu&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav__menu__item&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 显示用户名 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>XXX 你好！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何在 ES5 环境下实现一个const？</title>
    <link href="/blog/const-for-es5.html"/>
    <url>/blog/const-for-es5.html</url>
    
    <content type="html"><![CDATA[<h2 id="属性描述符："><a href="#属性描述符：" class="headerlink" title="属性描述符："></a>属性描述符：</h2><h3 id="对象里目前的属性描述符有两种："><a href="#对象里目前的属性描述符有两种：" class="headerlink" title="对象里目前的属性描述符有两种："></a>对象里目前的属性描述符有两种：</h3><ul><li>数据描述符：<strong>具有值的属性</strong></li><li>存取描述符：<strong>由getter与setter函数对描述的属性</strong></li></ul><h3 id="描述符功能："><a href="#描述符功能：" class="headerlink" title="描述符功能："></a>描述符功能：</h3><h4 id="数据描述符与存取描述符皆可修改"><a href="#数据描述符与存取描述符皆可修改" class="headerlink" title="数据描述符与存取描述符皆可修改:"></a>数据描述符与存取描述符皆可修改:</h4><ul><li>configurable：当前对象元素的属性描述符是否可改，是否可删除</li><li>enumerable：当前对象元素是否可枚举</li></ul><h4 id="唯有数据描述符可以修改："><a href="#唯有数据描述符可以修改：" class="headerlink" title="唯有数据描述符可以修改："></a>唯有数据描述符可以修改：</h4><ul><li>value: 当前对象元素的值</li><li>writable：当前对象元素的值是否可修改</li></ul><h4 id="唯有存取描述符可以修改："><a href="#唯有存取描述符可以修改：" class="headerlink" title="唯有存取描述符可以修改："></a>唯有存取描述符可以修改：</h4><ul><li>get：读取元素属性值时的操作</li><li>set：修改元素属性值时的操作</li></ul><h3 id="描述符可同时具有的键值："><a href="#描述符可同时具有的键值：" class="headerlink" title="描述符可同时具有的键值："></a>描述符可同时具有的键值：</h3><table><thead><tr><th></th><th>configurable</th><th>enumerable</th><th>value</th><th>writable</th><th>get</th><th>set</th></tr></thead><tbody><tr><td>数据描述符</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>存取描述符</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table><h2 id="const-实现原理"><a href="#const-实现原理" class="headerlink" title="const 实现原理"></a>const 实现原理</h2><blockquote><p>由于ES5环境没有block的概念，所以是无法百分百实现const，只能是挂载到某个对象下，要么是全局的window，要么就是自定义一个object来当容器</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> __const = <span class="hljs-keyword">function</span> <span class="hljs-title function_">__const</span> (data, value) &#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">data</span> = value <span class="hljs-comment">// 把要定义的data挂载到window下，并赋值value</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">window</span>, data, &#123; <span class="hljs-comment">// 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> value  &#125;,  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;  <span class="hljs-keyword">if</span> (data !== value) &#123; <span class="hljs-comment">// 当要对当前属性进行赋值时，则抛出错误！</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Assignment to constant variable.&#x27;</span>)    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> value    &#125;  &#125;&#125;)&#125;<span class="hljs-title function_">__const</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-keyword">delete</span> a<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) &#123; <span class="hljs-comment">// 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能</span><span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27;a&#x27;</span>) &#123; <span class="hljs-comment">// 因为不可枚举，所以不执行</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>[item])  &#125;&#125;a = <span class="hljs-number">20</span> <span class="hljs-comment">// 报错</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es5</tag>
      
      <tag>const</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端掌握知识程度</title>
    <link href="/blog/front-end.html"/>
    <url>/blog/front-end.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文将从以下十一个维度为读者总结前端基础知识</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/17150295c4bb639b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="1-如何在ES5环境下实现let"><a href="#1-如何在ES5环境下实现let" class="headerlink" title="1. 如何在ES5环境下实现let"></a>1. 如何在ES5环境下实现let</h2><blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote><p> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/1714616e2fd53bf8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p><code>babel</code>在<code>let</code>定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域</p><div class="code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)  <span class="hljs-comment">// 0 1 2 3 4 </span>  &#125;&#125;)();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)      <span class="hljs-comment">// Uncaught ReferenceError: i is not defined</span></code></pre></div><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p><ol><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li><li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li><li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li><li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ol><p><code>babel</code>的转化，其实只实现了第2、3、5点</p><h2 id="2-如何在ES5环境下实现const"><a href="#2-如何在ES5环境下实现const" class="headerlink" title="2. 如何在ES5环境下实现const"></a>2. 如何在ES5环境下实现const</h2><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty() </code>接收三个参数：</p><blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>obj</td><td>要在其上定义属性的对象</td></tr><tr><td>prop</td><td>要定义或修改的属性的名称</td></tr><tr><td>descriptor</td><td>将被定义或修改的属性描述符</td></tr></tbody></table><table><thead><tr><th>属性描述符</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td><td>undefined</td></tr><tr><td>get</td><td>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td><td>undefined</td></tr><tr><td>set</td><td>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td><td>undefined</td></tr><tr><td>writable</td><td>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td><td>false</td></tr><tr><td>enumerable</td><td>enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td><td>false</td></tr><tr><td>Configurable</td><td>configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td><td>false</td></tr></tbody></table><p>对于<code>const</code>不可修改的特性，我们通过设置writable属性来实现</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_const</span>(<span class="hljs-params">key, value</span>) &#123;        <span class="hljs-keyword">const</span> desc = &#123;                value,                <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>        &#125;        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">window</span>, key, desc)&#125;    <span class="hljs-title function_">_const</span>(<span class="hljs-string">&#x27;obj&#x27;</span>, &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)   <span class="hljs-comment">//定义obj</span>obj.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>               <span class="hljs-comment">//可以正常给obj的属性赋值</span>obj = &#123;&#125;                <span class="hljs-comment">//无法赋值新对象</span></code></pre></div><blockquote><p>参考资料：<a href="https://destiny-yyc.gitee.io/myblog/const-for-es5.html">如何在 ES5 环境下实现一个const?</a></p></blockquote><h2 id="3-手写call"><a href="#3-手写call" class="headerlink" title="3. 手写call()"></a>3. 手写call()</h2><blockquote><p><code>call() 方法</code>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数<br>语法：<code>function.call(thisArg, arg1, arg2, ...)</code></p></blockquote><p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//变更函数调用者示例</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)&#125;<span class="hljs-comment">// 测试</span><span class="hljs-keyword">const</span> obj = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;写代码像蔡徐抻&#x27;</span>&#125;obj.<span class="hljs-property">foo</span> = foo   <span class="hljs-comment">// 变更foo的调用者</span>obj.<span class="hljs-title function_">foo</span>()       <span class="hljs-comment">// &#x27;写代码像蔡徐抻&#x27;</span></code></pre></div><p>基于以上原理, 我们两句代码就能实现call()</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...args</span>) &#123;    thisArg.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>              <span class="hljs-comment">// this指向调用call的对象,即我们要改变this指向的函数</span>    <span class="hljs-keyword">return</span> thisArg.<span class="hljs-title function_">fn</span>(...args)     <span class="hljs-comment">// 执行函数并return其执行结果</span>&#125;</code></pre></div><p>但是我们有一些细节需要处理：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...args</span>) &#123;    <span class="hljs-keyword">const</span> fn = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>)        <span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>    thisArg = thisArg || <span class="hljs-variable language_">window</span>    <span class="hljs-comment">// 若没有传入this, 默认绑定window对象</span>    thisArg[fn] = <span class="hljs-variable language_">this</span>              <span class="hljs-comment">// this指向调用call的对象,即我们要改变this指向的函数</span>    <span class="hljs-keyword">const</span> result = thisArg[fn](...args)  <span class="hljs-comment">// 执行当前函数</span>    <span class="hljs-keyword">delete</span> thisArg[fn]              <span class="hljs-comment">// 删除我们声明的fn属性</span>    <span class="hljs-keyword">return</span> result                  <span class="hljs-comment">// 返回函数执行结果</span>&#125;<span class="hljs-comment">//测试</span>foo.<span class="hljs-title function_">myCall</span>(obj)     <span class="hljs-comment">// 输出&#x27;写代码像蔡徐抻&#x27;</span></code></pre></div><h2 id="4-手写apply"><a href="#4-手写apply" class="headerlink" title="4. 手写apply()"></a>4. 手写apply()</h2><blockquote><p><code>apply()</code>方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br>语法：<code>func.apply(thisArg, [argsArray])</code></p></blockquote><p><code>apply()</code>和<code>call()</code>类似，区别在于<code>call()</code>接收参数列表，而<code>apply()</code>接收一个参数数组，所以我们在<code>call()</code>的实现上简单改一下入参形式即可</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, args</span>) &#123;    <span class="hljs-keyword">const</span> fn = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>)        <span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>    thisArg = thisArg || <span class="hljs-variable language_">window</span>    <span class="hljs-comment">// 若没有传入this, 默认绑定window对象</span>    thisArg[fn] = <span class="hljs-variable language_">this</span>              <span class="hljs-comment">// this指向调用call的对象,即我们要改变this指向的函数</span>    <span class="hljs-keyword">const</span> result = thisArg[fn](...args)  <span class="hljs-comment">// 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）</span>    <span class="hljs-keyword">delete</span> thisArg[fn]              <span class="hljs-comment">// 删除我们声明的fn属性</span>    <span class="hljs-keyword">return</span> result                  <span class="hljs-comment">// 返回函数执行结果</span>&#125;<span class="hljs-comment">//测试</span>foo.<span class="hljs-title function_">myApply</span>(obj, [])     <span class="hljs-comment">// 输出&#x27;写代码像蔡徐抻&#x27;</span></code></pre></div><h2 id="5-手写bind"><a href="#5-手写bind" class="headerlink" title="5. 手写bind()"></a>5. 手写bind()</h2><blockquote><p><code>bind()</code>方法创建一个新的函数，在<code>bind()</code>被调用时，这个新函数的 this 被指定为<code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br>语法: <code>function.bind(thisArg, arg1, arg2, ...)</code></p></blockquote><p>从用法上看，似乎给<code>call/apply</code>包一层function就实现了<code>bind()</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...args</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">apply</span>(thisArg, args)    &#125;&#125;</code></pre></div><p>但我们忽略了三点：</p><ol><li><code>bind()</code>除了this还接收其他参数，<code>bind() </code>返回的函数也接收参数，这两部分的参数都要传给返回的函数</li><li>new会改变this指向：如果<code>bind</code>绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</li><li>没有保留原函数在原型链上的属性和方法</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) &#123;    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>    <span class="hljs-comment">// new优先级</span>    <span class="hljs-keyword">var</span> fbound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> self ? <span class="hljs-variable language_">this</span> : thisArg, args.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)))    &#125;    <span class="hljs-comment">// 继承原型上的属性和方法</span>    fbound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(self.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-keyword">return</span> fbound;&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;写代码像蔡徐抻&#x27;</span> &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)&#125;foo.<span class="hljs-title function_">myBind</span>(obj, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)()    <span class="hljs-comment">//输出写代码像蔡徐抻 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre></div><h2 id="6-手写一个防抖函数"><a href="#6-手写一个防抖函数" class="headerlink" title="6. 手写一个防抖函数"></a>6. 手写一个防抖函数</h2><p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p><blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框&#x2F;滚动条的监听事件处理，如果不做防抖，每输入一个字&#x2F;滚动屏幕，都会触发事件处理，造成性能浪费。</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout)        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            func.<span class="hljs-title function_">apply</span>(context, args)        &#125;, wait)    &#125;&#125;</code></pre></div><h2 id="7-手写一个节流函数"><a href="#7-手写一个节流函数" class="headerlink" title="7. 手写一个节流函数"></a>7. 手写一个节流函数</h2><blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行 </code>，函数节流<code>即每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>        <span class="hljs-keyword">if</span> (!timeout) &#123;            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                timeout = <span class="hljs-literal">null</span>                func.<span class="hljs-title function_">apply</span>(context, args)            &#125;, wait)        &#125;&#125;&#125;</code></pre></div><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;    <span class="hljs-keyword">var</span> prev = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;        <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;            func.<span class="hljs-title function_">apply</span>(context, args);            prev = now;        &#125;    &#125;&#125;</code></pre></div><h2 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8. 数组扁平化"></a>8. 数组扁平化</h2><blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>]这样的一维数组呢：</p></blockquote><h3 id="1-ES6的flat"><a href="#1-ES6的flat" class="headerlink" title="1. ES6的flat()"></a><strong>1. ES6的flat()</strong></h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)  <span class="hljs-comment">// [1, 1, 2, 1, 2, 3]</span></code></pre></div><h3 id="2-序列化后正则"><a href="#2-序列化后正则" class="headerlink" title="2. 序列化后正则"></a><strong>2. 序列化后正则</strong></h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<span class="hljs-keyword">const</span> str = <span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(arr).replace(/(\[|\])/g, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>]`</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str)   <span class="hljs-comment">// [1, 1, 2, 1, 2, 3]</span></code></pre></div><h3 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a><strong>3. 递归</strong></h3><p>对于树状结构的数据，最直接的处理方式就是递归</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">let</span> result = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;    item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> ? result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item)) : result.<span class="hljs-title function_">push</span>(item)  &#125;  <span class="hljs-keyword">return</span> result&#125;<span class="hljs-title function_">flat</span>(arr) <span class="hljs-comment">// [1, 1, 2, 1, 2, 3]</span></code></pre></div><h3 id="4-reduce-递归"><a href="#4-reduce-递归" class="headerlink" title="4. reduce()递归"></a><strong>4. reduce()递归</strong></h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(cur <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> ? <span class="hljs-title function_">flat</span>(cur) : cur)  &#125;, [])&#125;<span class="hljs-title function_">flat</span>(arr)  <span class="hljs-comment">// [1, 1, 2, 1, 2, 3]</span></code></pre></div><h3 id="5-迭代-展开运算符"><a href="#5-迭代-展开运算符" class="headerlink" title="5.迭代+展开运算符"></a><strong>5.迭代+展开运算符</strong></h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]</span><span class="hljs-comment">// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]]]<span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>)) &#123;  arr = [].<span class="hljs-title function_">concat</span>(...arr);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">// [1, 1, 2, 1, 2, 3, 4, 4, 4]</span></code></pre></div><h2 id="9-手写一个Promise"><a href="#9-手写一个Promise" class="headerlink" title="9. 手写一个Promise"></a>9. 手写一个Promise</h2><blockquote><p>实现一个符合规范的Promise篇幅比较长，建议阅读笔者上一篇文章：异步编程二三事 | Promise&#x2F;async&#x2F;Generator实现原理解析 | 9k字</p></blockquote><h1 id="JS面向对象"><a href="#JS面向对象" class="headerlink" title="JS面向对象"></a>JS面向对象</h1><p>在JS中一切皆对象，但JS并不是一种真正的面向对象(OOP)的语言，因为它缺少<code>var</code>的概念。虽然ES6引入了<code>class</code>和<code>extends</code>，使我们能够轻易地实现类和继承。但JS并不存在真实的类，JS的类是通过函数以及原型链机制模拟的，本小节的就来探究如何在ES5环境下利用函数和原型链实现JS面向对象的特性</p><p>在开始之前，我们先回顾一下原型链的知识，后续<code>new</code>和<code>继承</code>等实现都是基于原型链机制。很多介绍原型链的资料都能写上洋洋洒洒几千字，但我觉得读者们不需要把原型链想太复杂，容易把自己绕进去，其实在我看来，原型链的核心只需要记住三点：</p><ol><li><p>每个对象都有<code>new</code>属性，该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找</p></li><li><p>构造函数的<code>prototype属性</code>也指向实例的原型对象</p></li><li><p>原型对象的<code>constructor属性</code>指向构造函数</p></li></ol><h2 id="1-模拟实现new"><a href="#1-模拟实现new" class="headerlink" title="1. 模拟实现new"></a>1. 模拟实现new</h2><blockquote><p>首先我们要知道<code>new</code>做了什么</p></blockquote><ol><li><strong>创建一个新对象，并继承其构造函数的<code>prototype</code>，</strong>这一步是为了继承构造函数原型上的属性和方法</li><li><strong>执行构造函数，方法内的<code>this</code>被指定为该新实例</strong>，这一步是为了执行构造函数内的赋值操作</li><li><strong>返回新实例</strong>（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// new是关键字,这里我们用函数来模拟,new Foo(args) &lt;=&gt; myNew(Foo, args)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">foo, ...args</span>) &#123;  <span class="hljs-comment">// 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype</span>  <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(foo.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)    <span class="hljs-comment">// 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入</span>  <span class="hljs-keyword">let</span> result = foo.<span class="hljs-title function_">apply</span>(obj, args)  <span class="hljs-comment">// 如果构造方法已经return了一个对象，那么就返回该对象，否则返回myNew创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象）</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(result) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ? result : obj&#125;<span class="hljs-comment">// 测试：</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name&#125;<span class="hljs-keyword">const</span> newObj = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Foo</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj)                 <span class="hljs-comment">// Foo &#123;name: &quot;zhangsan&quot;&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>)  <span class="hljs-comment">// true</span></code></pre></div><h2 id="2-ES5如何实现继承"><a href="#2-ES5如何实现继承" class="headerlink" title="2. ES5如何实现继承"></a>2. ES5如何实现继承</h2><blockquote><p>说到继承，最容易想到的是ES6的extends，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承</p></blockquote><h3 id="一-原型链继承"><a href="#一-原型链继承" class="headerlink" title="一. 原型链继承"></a>一. 原型链继承</h3><p>原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;写代码像蔡徐抻&#x27;</span>&#125;<span class="hljs-comment">// 父类的原型方法</span><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-comment">// 子类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span> <span class="hljs-comment">// 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要</span><span class="hljs-comment">// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法</span><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()child.<span class="hljs-property">name</span>          <span class="hljs-comment">// &#x27;写代码像蔡徐抻&#x27;</span>child.<span class="hljs-title function_">getName</span>()     <span class="hljs-comment">// &#x27;写代码像蔡徐抻&#x27;</span></code></pre></div><p>原型继承的缺点:</p><ol><li>由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例</li><li>在创建子类实例时无法向父类构造传参, 即没有实现<code>super()</code>的功能</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例:</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [<span class="hljs-string">&#x27;写代码像蔡徐抻&#x27;</span>] &#125;<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span> <span class="hljs-comment">// 测试</span><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()child1.<span class="hljs-property">name</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;foo&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;foo&#x27;] (预期是[&#x27;写代码像蔡徐抻&#x27;], 对child1.name的修改引起了所有child实例的变化)</span></code></pre></div><h3 id="二-构造函数继承"><a href="#二-构造函数继承" class="headerlink" title="二. 构造函数继承"></a>二. 构造函数继承</h3><p>构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的<code>this</code>，让父类的构造函数把成员属性和方法都挂到<code>子类的this</code>上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [name]&#125;<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>)   <span class="hljs-comment">// 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上</span>&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()child1.<span class="hljs-property">name</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;foo&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span>child2.<span class="hljs-title function_">getName</span>()                  <span class="hljs-comment">// 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法</span></code></pre></div><p>构造函数继承的缺点:</p><ol><li>继承不到父类原型上的属性和方法</li></ol><h3 id="三-组合式继承"><a href="#三-组合式继承" class="headerlink" title="三. 组合式继承"></a>三. 组合式继承</h3><p>既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [name]&#125;<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 构造函数继承</span>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>) &#125;<span class="hljs-comment">//原型链继承</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><span class="hljs-comment">//测试</span><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()child1.<span class="hljs-property">name</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;foo&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span>child2.<span class="hljs-title function_">getName</span>()                  <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span></code></pre></div><p>组合式继承的缺点:</p><ol><li>每次创建子类实例都执行了两次构造函数(<code>new</code>和<code>new Parent()</code>)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅</li></ol><h3 id="四-寄生式组合继承"><a href="#四-寄生式组合继承" class="headerlink" title="四. 寄生式组合继承"></a>四. 寄生式组合继承</h3><p>为了解决构造函数被执行两次的问题, 我们将<code>指向父类实例</code>改为<code>指向父类原型</code>, 减去一次构造函数的执行</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [name]&#125;<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 构造函数继承</span>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>) &#125;<span class="hljs-comment">//原型链继承</span><span class="hljs-comment">// Child.prototype = new Parent()</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  <span class="hljs-comment">//将`指向父类实例`改为`指向父类原型`</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><span class="hljs-comment">//测试</span><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()child1.<span class="hljs-property">name</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;foo&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>)          <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span>child2.<span class="hljs-title function_">getName</span>()                  <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span></code></pre></div><p>但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给<code>Child.prototype</code>增加一个<code>getName()</code>方法，那么会导致<code>Parent.prototype</code>也增加或被覆盖一个<code>getName()</code>方法，为了解决这个问题，我们给<code>Parent.prototype</code>做一个浅拷贝</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [name]&#125;<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 构造函数继承</span>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>) &#125;<span class="hljs-comment">//原型链继承</span><span class="hljs-comment">// Child.prototype = new Parent()</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)  <span class="hljs-comment">//将`指向父类实例`改为`指向父类原型`</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><span class="hljs-comment">//测试</span><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()child.<span class="hljs-title function_">getName</span>()                  <span class="hljs-comment">// [&#x27;zhangsan&#x27;]</span>parent.<span class="hljs-title function_">getName</span>()                 <span class="hljs-comment">// 报错, 找不到getName()</span></code></pre></div><p>到这里我们就完成了ES5环境下的继承的实现，这种继承方式称为<code>寄生组合式继承</code>，是目前最成熟的继承方式，babel对ES6继承的转化也是使用了寄生组合式继承</p><p>我们回顾一下实现过程：<br>一开始最容易想到的是<code>原型链继承</code>，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<code>对子类实例继承的引用类型的修改会影响到所有的实例对象</code>以及<code>无法向父类的构造方法传参</code>。<br>因此我们引入了<code>构造函数继承</code>, 通过在子类构造函数中调用父类构造函数并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承<code>不能继承到父类原型链上的属性和方法</code>。<br>所以我们综合了两种继承的优点，提出了<code>组合式继承</code>，但组合式继承也引入了新的问题，它<code>每次创建子类实例都执行了两次父类构造方法</code>，我们通过将<code>子类原型指向父类实例</code>改为<code>子类原型指向父类原型的浅拷贝</code>来解决这一问题，也就是最终实现 —— <code>寄生组合式继承</code></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714fd86c8983189~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="V8引擎机制"><a href="#V8引擎机制" class="headerlink" title="V8引擎机制"></a>V8引擎机制</h1><h2 id="1-V8如何执行一段JS代码"><a href="#1-V8如何执行一段JS代码" class="headerlink" title="1. V8如何执行一段JS代码"></a>1. V8如何执行一段JS代码</h2><ol><li><strong>预解析</strong>：检查语法错误但不生成AST</li><li><strong>生成AST</strong>：经过词法&#x2F;语法分析，生成抽象语法树</li><li><strong>生成字节码</strong>：基线编译器(Ignition)将AST转换成字节码</li><li><strong>生成机器码</strong>：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度</li></ol><p>上面几点只是V8执行机制的极简总结，建议阅读参考资料：</p><blockquote><p>1.<a href="https://juejin.cn/post/6844903990073753613">V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道</a><br>2.<a href="https://juejin.cn/post/6844904021451505677">JavaScript 引擎 V8 执行流程概述</a></p></blockquote><h2 id="2-介绍一下引用计数和标记清除"><a href="#2-介绍一下引用计数和标记清除" class="headerlink" title="2. 介绍一下引用计数和标记清除"></a>2. 介绍一下引用计数和标记清除</h2><ul><li><p>引用计数：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。</p></li><li><p>标记清除：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。</p></li></ul><h2 id="3-V8如何进行垃圾回收"><a href="#3-V8如何进行垃圾回收" class="headerlink" title="3. V8如何进行垃圾回收"></a>3. V8如何进行垃圾回收</h2><p>JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17149730709e41a4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p><strong>栈内存的回收：</strong></p><p>栈内存调用栈上下文切换后就被回收，比较简单</p><p><strong>堆内存的回收：</strong></p><p>V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/1714980cac75fc32~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><ul><li><p>新生代内存回收机制：</p><ul><li>新生代内存容量小，64位系统下仅有32M。新生代内存分为From、To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From&#x2F;To，等待下一次回收</li></ul></li><li><p>老生代内存回收机制</p><ul><li><strong>晋升</strong>：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中<br><strong>标记清除</strong>：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象<br><strong>整理内存碎片</strong>：把对象挪到内存的一端</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/1714a1f7c054c657~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844903591510016007#heading-10">聊聊V8引擎的垃圾回收</a></p></blockquote><h2 id="4-JS相较于C-等语言为什么慢，V8做了哪些优化"><a href="#4-JS相较于C-等语言为什么慢，V8做了哪些优化" class="headerlink" title="4. JS相较于C++等语言为什么慢，V8做了哪些优化"></a>4. JS相较于C++等语言为什么慢，V8做了哪些优化</h2><ul><li><p>JS的问题：</p><ul><li><p><strong>动态类型</strong>：导致每次存取属性&#x2F;寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化</p></li><li><p><strong>属性存取</strong>：C++&#x2F;Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询</p></li></ul></li><li><p>V8的优化：</p><ul><li><p>**优化JIT(即时编译)**：相较于C++&#x2F;Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。</p></li><li><p><strong>隐藏类</strong>：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类</p></li><li><p><strong>内嵌缓存</strong>：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -&gt; 根据属性名查找偏移值 -&gt; 计算该属性地址，内嵌缓存就是对这一过程结果的缓存</p></li><li><p>垃圾回收管理：上文已介绍</p></li></ul></li></ul><blockquote><p>参考资料：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/27628685">为什么V8引擎这么快？</a></p></blockquote><h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h1><h2 id="1-浏览器的渲染过程是怎样的"><a href="#1-浏览器的渲染过程是怎样的" class="headerlink" title="1. 浏览器的渲染过程是怎样的"></a>1. 浏览器的渲染过程是怎样的</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/5/17013323c225bd62~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>大体流程如下：</p><ol><li><p>HTML和CSS经过各自解析，生成DOM树和CSSOM树</p></li><li><p>合并成为渲染树</p></li><li><p>根据渲染树进行布局</p></li><li><p>最后调用GPU进行绘制，显示在屏幕上</p></li></ol><h2 id="2-如何根据浏览器渲染机制加快首屏速度"><a href="#2-如何根据浏览器渲染机制加快首屏速度" class="headerlink" title="2. 如何根据浏览器渲染机制加快首屏速度"></a>2. 如何根据浏览器渲染机制加快首屏速度</h2><ol><li><p>优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度</p></li><li><p>避免资源下载阻塞文档解析：浏览器解析到<code>&lt;script&gt;</code>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常<code>&lt;script&gt;</code>标签放在底部，或者加上<code>defer</code>、<code>async</code>来进行异步下载</p></li></ol><h2 id="3-什么是回流-重排-，什么情况下会触发回流"><a href="#3-什么是回流-重排-，什么情况下会触发回流" class="headerlink" title="3. 什么是回流(重排)，什么情况下会触发回流"></a>3. 什么是回流(重排)，什么情况下会触发回流</h2><ul><li><p>当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流</p></li><li><p>DOM元素的几何属性(<code>width/height/padding/margin/border</code>)发生变化时会触发回流</p></li><li><p>DOM元素移动或增加会触发回流</p></li><li><p>读写<code>offset/scroll/client</code>等属性时会触发回流</p></li><li><p>调用<code>window.getComputedStyle</code>会触发回流</p></li></ul><h2 id="4-什么是重绘，什么情况下会触发重绘"><a href="#4-什么是重绘，什么情况下会触发重绘" class="headerlink" title="4. 什么是重绘，什么情况下会触发重绘"></a>4. 什么是重绘，什么情况下会触发重绘</h2><ul><li>DOM样式发生了变化，但没有影响DOM的几何属性时，会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流</li></ul><h2 id="5-什么是GPU加速，如何使用GPU加速，GPU加速的缺点"><a href="#5-什么是GPU加速，如何使用GPU加速，GPU加速的缺点" class="headerlink" title="5. 什么是GPU加速，如何使用GPU加速，GPU加速的缺点"></a>5. 什么是GPU加速，如何使用GPU加速，GPU加速的缺点</h2><ul><li><strong>优点</strong>：使用transform、opacity、filters等属性时，会直接在GPU中完成处理，这些属性的变化不会引起回流重绘</li><li><strong>缺点</strong>：GPU渲染字体会导致字体模糊，过多的GPU处理会导致内存问题</li></ul><h2 id="6-如何减少回流"><a href="#6-如何减少回流" class="headerlink" title="6. 如何减少回流"></a>6. 如何减少回流</h2><ul><li>使用<code>class</code>替代<code>style</code>，减少style的使用</li><li>使用<code>resize</code>、<code>scroll</code>时进行防抖和节流处理，这两者会直接导致回流</li><li>使用<code>visibility</code>替换<code>display: none</code>，因为前者只会引起重绘，后者会引发回流</li><li>批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流</li><li>避免触发同步布局事件，我们在获取<code>offsetWidth</code>这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对<code>offset/scroll/client</code>等属性进行查询时都会触发回流</li><li>对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/1714a1d84ab05ba9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844903846834094094">必须明白的浏览器渲染机制</a></p></blockquote><h1 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h1><h2 id="1-介绍一下浏览器缓存位置和优先级"><a href="#1-介绍一下浏览器缓存位置和优先级" class="headerlink" title="1. 介绍一下浏览器缓存位置和优先级"></a>1. 介绍一下浏览器缓存位置和优先级</h2><ol><li>Service Worker</li><li>Memory Cache（内存缓存）</li><li>Disk Cache（硬盘缓存）</li><li>Push Cache（推送缓存）</li><li>以上缓存都没命中就会进行网络请求</li></ol><h2 id="2-说说不同缓存间的差别"><a href="#2-说说不同缓存间的差别" class="headerlink" title="2. 说说不同缓存间的差别"></a>2. 说说不同缓存间的差别</h2><ol><li><strong>Service Worker</strong></li></ol><p>和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的</p><ol start="2"><li><strong>Memory Cache</strong></li></ol><p>即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放</p><ol start="3"><li><strong>Disk Cache</strong></li></ol><p>即硬盘缓存，相较于内存缓存，硬盘缓存的持续性和容量更优，它会根据HTTP header的字段判断哪些资源需要缓存</p><ol start="4"><li><strong>Push Cache</strong></li></ol><p>即推送缓存，是HTTP&#x2F;2的内容，目前应用较少</p><h2 id="3-介绍一下浏览器缓存策略"><a href="#3-介绍一下浏览器缓存策略" class="headerlink" title="3. 介绍一下浏览器缓存策略"></a>3. 介绍一下浏览器缓存策略</h2><h3 id="强缓存-不要向服务器询问的缓存"><a href="#强缓存-不要向服务器询问的缓存" class="headerlink" title="强缓存(不要向服务器询问的缓存)"></a>强缓存(不要向服务器询问的缓存)</h3><ul><li><p><strong>设置Expires</strong></p><ul><li>即过期时间，例如「Expires: Thu, 26 Dec 2019 10:30:42 GMT」表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。</li></ul></li><li><p><strong>设置Cache-Control</strong></p><ul><li>HTTP&#x2F;1.1新增字段，Cache-Control可以通过max-age字段来设置过期时间，例如「Cache-Control:max-age&#x3D;3600」除此之外Cache-Control还能设置private&#x2F;no-cache等多种字段</li></ul></li></ul><h3 id="协商缓存-需要向服务器询问缓存是否已经过期"><a href="#协商缓存-需要向服务器询问缓存是否已经过期" class="headerlink" title="协商缓存(需要向服务器询问缓存是否已经过期)"></a>协商缓存(需要向服务器询问缓存是否已经过期)</h3><ul><li><p><strong>Last-Modified</strong></p><ul><li>即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上Last-Modified ，当浏览器再次请求该资源时，浏览器会在请求头中带上If-Modified-Since 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间1</li></ul></li><li><p><strong>ETag</strong></p><ul><li>HTTP&#x2F;1.1新增字段，表示文件唯一标识，只要文件内容改动，ETag就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -&gt; 浏览器再次请求时发送 If-None-Match -&gt; 如果ETag值不匹配，说明文件已经改变，返回新资源并更新ETag，若匹配则返回304</li></ul></li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li><p>ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存</p></li><li><p>如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间</p></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/1714a298b93c3208~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844903473268391943">浏览器缓存机制剖析</a></p></blockquote><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="1-讲讲网络OSI七层模型，TCP-x2F-IP和HTTP分别位于哪一层"><a href="#1-讲讲网络OSI七层模型，TCP-x2F-IP和HTTP分别位于哪一层" class="headerlink" title="1. 讲讲网络OSI七层模型，TCP&#x2F;IP和HTTP分别位于哪一层"></a>1. 讲讲网络OSI七层模型，TCP&#x2F;IP和HTTP分别位于哪一层</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/28/16fec363208256b8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><table><thead><tr><th>模型</th><th>概述</th><th>单位</th></tr></thead><tbody><tr><td>物理层</td><td>网络连接介质，如网线、光缆，数据在其中以比特为单位传输</td><td>bit</td></tr><tr><td>数据链路层</td><td>数据链路层将比特封装成数据帧并传递</td><td>帧</td></tr><tr><td>网络层</td><td>定义IP地址，定义路由功能，建立主机到主机的通信</td><td>数据包</td></tr><tr><td>传输层</td><td>负责将数据进行可靠或者不可靠传递，建立端口到端口的通信</td><td>数据段</td></tr><tr><td>会话层</td><td>控制应用程序之间会话能力，区分不同的进程</td><td></td></tr><tr><td>表示层</td><td>数据格式标识，基本压缩加密功能</td><td></td></tr><tr><td>应用层</td><td>各种应用软件</td><td></td></tr></tbody></table><h2 id="2-常见HTTP状态码有哪些"><a href="#2-常见HTTP状态码有哪些" class="headerlink" title="2. 常见HTTP状态码有哪些"></a>2. 常见HTTP状态码有哪些</h2><ul><li><p><strong>2xx 开头（请求成功）</strong></p><ul><li><code>200 OK</code>：客户端发送给服务器的请求被正常处理并返回</li></ul></li><li><p><strong>3xx 开头（重定向）</strong></p><ul><li><code>301 Moved Permanently</code>：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置</li><li><code>302 Moved Permanently</code>：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li><code>304 Not Modified</code>：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li></ul></li><li><p><strong>4xx 开头（客户端错误）</strong></p><ul><li><code>400 Bad Request</code>：错误请求，服务器不理解请求的语法，常见于客户端传参错误</li><li><code>401 Unauthorized</code>：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录</li><li><code>403 Forbidden</code>：禁止，服务器拒绝请求，常见于客户端权限不足</li><li><code>404 Not Found</code>：未找到，服务器找不到对应资源</li></ul></li><li><p><strong>5xx 开头（服务端错误）</strong></p><ul><li><p><code>500 Inter Server Error</code>：服务器内部错误，服务器遇到错误，无法完成请求</p></li><li><p><code>501 Not Implemented</code>：尚未实施，服务器不具备完成请求的功能</p></li><li><p><code>502 Bad Gateway</code>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p></li><li><p><code>503 service unavailable</code>：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。</p></li></ul></li></ul><h2 id="3-GET请求和POST请求有何区别"><a href="#3-GET请求和POST请求有何区别" class="headerlink" title="3. GET请求和POST请求有何区别"></a>3. GET请求和POST请求有何区别</h2><h3 id="标准答案："><a href="#标准答案：" class="headerlink" title="标准答案："></a>标准答案：</h3><ul><li>GET请求参数放在URL上，POST请求参数放在请求体里</li><li>GET请求参数长度有限制，POST请求参数长度可以非常大</li><li>POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录</li><li>GET请求能缓存，POST不能</li></ul><h3 id="更进一步："><a href="#更进一步：" class="headerlink" title="更进一步："></a>更进一步：</h3><p>其实HTTP协议并没有要求GET&#x2F;POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：GET请求是幂等性的，而POST请求不是</p><h3 id="幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。"><a href="#幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。" class="headerlink" title="幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。"></a>幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。</h3><p>由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增&#x2F;删除等操作适合用POST</p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844903489127219214">HTTP｜GET 和 POST 区别？网上多数答案都是错的</a></p></blockquote><h2 id="4-HTTP的请求报文由哪几部分组成"><a href="#4-HTTP的请求报文由哪几部分组成" class="headerlink" title="4. HTTP的请求报文由哪几部分组成"></a>4. HTTP的请求报文由哪几部分组成</h2><p>一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/1/16ffe7606c8db5e7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>响应报文和请求报文结构类似，不再赘述</p><h2 id="5-HTTP常见请求-x2F-响应头及其含义"><a href="#5-HTTP常见请求-x2F-响应头及其含义" class="headerlink" title="5. HTTP常见请求&#x2F;响应头及其含义"></a>5. HTTP常见请求&#x2F;响应头及其含义</h2><h3 id="通用头（请求头和响应头都有的首部）"><a href="#通用头（请求头和响应头都有的首部）" class="headerlink" title="通用头（请求头和响应头都有的首部）"></a>通用头（请求头和响应头都有的首部）</h3><table><thead><tr><th>字段</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存</td><td>public：表示响应可以被任何对象缓存(包括客户端&#x2F;代理服务器) private(默认值)：响应只能被单个客户缓存,不能被代理服务器缓存 no-cache：缓存要经过服务器验证，在浏览器使用缓存前，会对比ETag，若没变则返回304，使用缓存 no-store：禁止任何缓存</td></tr><tr><td>Connection</td><td>是否需要持久连接(HTTP 1.1默认持久连接)</td><td>keep-alive &#x2F; close</td></tr><tr><td>Transfer-Encoding</td><td>报文主体的传输编码格式</td><td>chunked(分块) &#x2F; identity(未压缩和修改) &#x2F; gzip(LZ77压缩) &#x2F; compress(LZW压缩,弃用) &#x2F; deflate(zlib结构压缩)</td></tr></tbody></table><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Accept</td><td>告知（服务器）客户端可以处理的内容类型</td><td>text&#x2F;html、image&#x2F;<em>、</em>&#x2F;*</td></tr><tr><td>If-Modified-Since</td><td>将<code>Last-Modified</code>的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304</td><td>示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</td></tr><tr><td>If-Unmodified-Since</td><td>将<code>Last-Modified</code>的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传。通俗点说<code>If-Unmodified-Since</code>是文件没有修改时下载，<code>If-Modified-Since</code>是文件修改时下载</td><td>示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT</td></tr><tr><td>If-None-Match</td><td>将<code>ETag</code>的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304</td><td>示例：If-None-Match: “bfc13a6472992d82d”</td></tr><tr><td>If-Match</td><td>将<code>ETag</code>的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传</td><td>示例：If-Match: “bfc129c88ca92d82d”</td></tr><tr><td>Range</td><td>告知服务器返回文件的哪一部分, 用于断点续传</td><td>示例：Range: bytes&#x3D;200-1000, 2000-6576, 19000-</td></tr><tr><td>Host</td><td>指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号</td><td>示例：Host:<a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>User-Agent</td><td>告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本</td><td>User-Agent: Mozilla&#x2F;<version> (<system-information>) <platform> (<platform-details>) <extensions></td></tr></tbody></table><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Location</td><td>需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义</td><td>Location: <url></td></tr><tr><td>ETag</td><td>资源的特定版本的标识符，如果内容没有改变，Web服务器不需要发送完整的响应</td><td>ETag: “<etag_value>“</td></tr><tr><td>Server</td><td>处理请求的源头服务器所用到的软件相关信息</td><td>Server: <product></td></tr></tbody></table><h3 id="实体头（针对请求报文和响应报文的实体部分使用首部）"><a href="#实体头（针对请求报文和响应报文的实体部分使用首部）" class="headerlink" title="实体头（针对请求报文和响应报文的实体部分使用首部）"></a>实体头（针对请求报文和响应报文的实体部分使用首部）</h3><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持http请求的方法</td><td>Allow: <http-methods>，示例：Allow: GET, POST, HEAD</td></tr><tr><td>Last-Modified</td><td>资源最后的修改时间，用作一个验证器来判断接收到的或者存储的资源是否彼此一致，精度不如ETag</td><td>示例：Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT</td></tr><tr><td>Expires</td><td>响应过期时间</td><td>Expires: <http-date>，示例：Expires: Wed, 21 Oct 2020 07:28:00 GMT</td></tr></tbody></table><p>HTTP首部当然不止这么几个，但为了避免写太多大家记不住(主要是别的我也没去看)，这里只介绍了一些常用的，详细的可以看<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">MDN的文档</a></p><h2 id="6-HTTP-x2F-1-0和HTTP-x2F-1-1有什么区别"><a href="#6-HTTP-x2F-1-0和HTTP-x2F-1-1有什么区别" class="headerlink" title="6. HTTP&#x2F;1.0和HTTP&#x2F;1.1有什么区别"></a>6. HTTP&#x2F;1.0和HTTP&#x2F;1.1有什么区别</h2><ul><li><strong>长连接</strong>： HTTP&#x2F;1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时</li><li><strong>缓存处理</strong>： HTTP&#x2F;1.1引入<code>Entity tag, If-Unmodified-Since, If-Match, If-None-Match</code>等新的请求头来控制缓存，详见浏览器缓存小节</li><li><strong>带宽优化及网络连接的使用</strong>： HTTP1.1则在请求头引入了range头域，支持断点续传功能</li><li><strong>Host头处理</strong>： 在HTTP&#x2F;1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误</li></ul><h2 id="7-介绍一下HTTP-x2F-2-0新特性"><a href="#7-介绍一下HTTP-x2F-2-0新特性" class="headerlink" title="7. 介绍一下HTTP&#x2F;2.0新特性"></a>7. 介绍一下HTTP&#x2F;2.0新特性</h2><ul><li><p>多路复用： 即多个请求都通过一个TCP连接并发地完成</p></li><li><p>服务端推送： 服务端能够主动把资源推送给客户端</p></li><li><p>新的二进制格式： HTTP&#x2F;2采用二进制格式传输数据，相比于HTTP&#x2F;1.1的文本格式，二进制格式具有更好的解析性和拓展性</p></li><li><p>header压缩： HTTP&#x2F;2压缩消息头，减少了传输数据的大小</p></li></ul><h2 id="8-说说HTTP-x2F-2-0多路复用基本原理以及解决的问题"><a href="#8-说说HTTP-x2F-2-0多路复用基本原理以及解决的问题" class="headerlink" title="8. 说说HTTP&#x2F;2.0多路复用基本原理以及解决的问题"></a>8. 说说HTTP&#x2F;2.0多路复用基本原理以及解决的问题</h2><h3 id="HTTP-x2F-2解决的问题，就是HTTP-x2F-1-1存在的问题："><a href="#HTTP-x2F-2解决的问题，就是HTTP-x2F-1-1存在的问题：" class="headerlink" title="HTTP&#x2F;2解决的问题，就是HTTP&#x2F;1.1存在的问题："></a>HTTP&#x2F;2解决的问题，就是HTTP&#x2F;1.1存在的问题：</h3><ul><li><p>TCP慢启动： TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML&#x2F;JS&#x2F;CSS&#x2F;icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。</p></li><li><p>多条TCP连接竞争带宽： 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。</p></li><li><p>HTTP&#x2F;1.1队头阻塞： 尽管HTTP&#x2F;1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。</p></li></ul><p>为了解决以上几个问题，<strong>HTTP&#x2F;2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用</strong></p><p><strong>实现原理</strong>： HTTP&#x2F;2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。</p><h2 id="9-说说HTTP-x2F-3-0"><a href="#9-说说HTTP-x2F-3-0" class="headerlink" title="9. 说说HTTP&#x2F;3.0"></a>9. 说说HTTP&#x2F;3.0</h2><p>尽管HTTP&#x2F;2解决了很多1.1的问题，但HTTP&#x2F;2仍然存在一些缺陷，这些缺陷并不是来自于HTTP&#x2F;2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP&#x2F;1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP&#x2F;2只有一个TCP连接，阻塞的问题便被放大了。</p><p>由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP&#x2F;3选择了一个折衷的方法——UDP协议，HTTP&#x2F;2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。</p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844904001528397837#heading-9">http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记</a> (推荐阅读)</p></blockquote><h2 id="10-HTTP和HTTPS有何区别"><a href="#10-HTTP和HTTPS有何区别" class="headerlink" title="10. HTTP和HTTPS有何区别"></a>10. HTTP和HTTPS有何区别</h2><ul><li>HTTPS使用443端口，而HTTP使用80</li><li>HTTPS需要申请证书</li><li>HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全</li><li>HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包</li></ul><h2 id="11-HTTPS是如何进行加密的"><a href="#11-HTTPS是如何进行加密的" class="headerlink" title="11. HTTPS是如何进行加密的"></a>11. HTTPS是如何进行加密的</h2><p>我们通过分析几种加密方式，层层递进，理解HTTPS的加密方式以及为什么使用这种加密方式：</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/170097ce30734773~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>这种方式一定程度上保证了数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密。私钥自己留着，公钥发给对方。这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密。这样攻击者只拿到传输过程中的公钥也无法破解传输的内容</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700980f4879f2b8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>尽管非对称加密解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍然可以用篡改公钥的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的性能差了不少</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/17009369c26da64b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h3 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h3><p>上面这种方法的弱点在于，客户端不知道公钥是由服务端返回，还是中间人返回的，因此我们再引入一个第三方认证的环节：即第三方使用私钥加密我们<code>自己的公钥</code>，浏览器已经内置一些权威第三方认证机构的公钥，浏览器会使用<code>第三方的公钥</code>来解开<code>第三方私钥加密过的我们自己的公钥</code>，从而获取公钥，如果能成功解密，就说明获取到的<code>自己的公钥</code>是正确的</p><p>但第三方认证也未能完全解决问题，第三方认证是面向所有人的，中间人也能申请证书，如果中间人使用自己的证书掉包原证书，客户端还是无法确认公钥的真伪</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700962e1949c343~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向hash而来，一旦构成数字签名的信息发生变化，hash值就会改变，这就构成了公钥来源的唯一标识。</p><p>具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到CA(第三方认证中心)去申请数字证书，CA会通过一种单向hash算法(比如MD5)，生成一串摘要，这串摘要就是这堆信息的唯一标识，然后CA还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们。</p><p>浏览器拿到数字签名后，会使用浏览器本地内置的CA公钥解开数字证书并验证，从而拿到正确的公钥。由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密。</p><p>综上所述，HTTPS在验证阶段使用非对称加密+第三方认证+数字签名获取正确的公钥，获取到正确的公钥后以对称加密的方式通信</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e043d3a1add2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><blockquote><p>参考资料：<a href="https://juejin.cn/post/6844903608421449742#heading-5">看图学HTTPS</a></p></blockquote><h1 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h1><h2 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h2><blockquote><p>CSRF即Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p></blockquote><p>假如黑客在自己的站点上放置了其他网站的外链，例如<code>www.weibo.com/api</code>，默认情况下，浏览器会带着<code>weibo.com</code>的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。</p><h2 id="如何防御CSRF攻击"><a href="#如何防御CSRF攻击" class="headerlink" title="如何防御CSRF攻击"></a>如何防御CSRF攻击</h2><ul><li>验证<code>Token</code>：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求</li><li>验证<code>Referer</code>：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造</li><li>设置<code>SameSite</code>：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一</li></ul><h2 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h2><blockquote><p>XSS即Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入JS代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取</p></blockquote><h2 id="XSS攻击有哪些类型"><a href="#XSS攻击有哪些类型" class="headerlink" title="XSS攻击有哪些类型"></a>XSS攻击有哪些类型</h2><ul><li><strong>存储型</strong>：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。</li><li><strong>反射型</strong>：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码</li><li><strong>DOM型</strong>：将攻击脚本写在URL中，诱导用户点击该URL，如果URL被解析，那么攻击脚本就会被运行。和前两者的差别主要在于DOM型攻击不经过服务端</li></ul><h2 id="如何防御XSS攻击"><a href="#如何防御XSS攻击" class="headerlink" title="如何防御XSS攻击"></a>如何防御XSS攻击</h2><ul><li><strong>输入检查</strong>：对输入内容中的<code>&lt;script&gt;&lt;iframe&gt;</code>等标签进行转义或者过滤</li><li><strong>设置httpOnly</strong>：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie</li><li><strong>开启CSP</strong>：即开启白名单，可阻止白名单以外的资源加载和运行</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ff9939df9d71~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-手写冒泡排序"><a href="#1-手写冒泡排序" class="headerlink" title="1. 手写冒泡排序"></a>1. 手写冒泡排序</h2><blockquote><p>冒泡排序应该是很多人第一个接触的排序，比较简单，不展开讲解了</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>)&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123;      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-keyword">let</span> temp = arr[j]        arr[j] = arr[j+<span class="hljs-number">1</span>]        arr[j+<span class="hljs-number">1</span>] = temp      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h2 id="2-如何优化一个冒泡排序"><a href="#2-如何优化一个冒泡排序" class="headerlink" title="2. 如何优化一个冒泡排序"></a>2. 如何优化一个冒泡排序</h2><blockquote><p>冒泡排序总会执行(N-1)+(N-2)+(N-3)+..+2+1趟，但如果运行到当中某一趟时排序已经完成，或者输入的是一个有序数组，那么后边的比较就都是多余的，为了避免这种情况，我们增加一个flag，判断排序是否在中途就已经完成（也就是判断有无发生元素交换）</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>)&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123;      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        flag = <span class="hljs-literal">false</span>        <span class="hljs-keyword">let</span> temp = arr[j]        arr[j] = arr[j+<span class="hljs-number">1</span>]        arr[j+<span class="hljs-number">1</span>] = temp      &#125;    &#125;    <span class="hljs-comment">// 这个flag的含义是：如果`某次循环`中没有交换过元素，那么意味着排序已经完成</span>    <span class="hljs-keyword">if</span>(flag)<span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h2 id="3-手写快速排序"><a href="#3-手写快速排序" class="headerlink" title="3. 手写快速排序"></a>3. 手写快速排序</h2><h3 id="快排基本步骤："><a href="#快排基本步骤：" class="headerlink" title="快排基本步骤："></a>快排基本步骤：</h3><ol><li><p>选取基准元素</p></li><li><p>比基准元素小的元素放到左边，大的放右边</p></li><li><p>在左右子数组中重复步骤一二，直到数组只剩下一个元素</p></li><li><p>向上逐级合并数组</p></li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr          <span class="hljs-comment">//递归终止条件</span>    <span class="hljs-keyword">const</span> pivot = arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span> | <span class="hljs-number">0</span>        <span class="hljs-comment">//基准点</span>    <span class="hljs-keyword">const</span> pivotValue = arr.<span class="hljs-title function_">splice</span>(pivot, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]    <span class="hljs-keyword">const</span> leftArr = []    <span class="hljs-keyword">const</span> rightArr = []    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;        val &gt; pivotValue ? rightArr.<span class="hljs-title function_">push</span>(val) : leftArr.<span class="hljs-title function_">push</span>(val)    &#125;)    <span class="hljs-keyword">return</span> [ ...<span class="hljs-title function_">quickSort</span>(leftArr), pivotValue, ...<span class="hljs-title function_">quickSort</span>(rightArr)]&#125;</code></pre></div><h2 id="4-如何优化一个快速排序"><a href="#4-如何优化一个快速排序" class="headerlink" title="4. 如何优化一个快速排序"></a>4. 如何优化一个快速排序</h2><h3 id="1-原地排序"><a href="#1-原地排序" class="headerlink" title="1. 原地排序"></a>1. 原地排序</h3><p>上边这个快排只是让读者找找感觉，我们不能这样写快排，如果每次都开两个数组，会消耗很多内存空间，数据量大时可能造成内存溢出，我们要避免开新的内存空间，即原地完成排序</p><p>我们可以用元素交换来取代开新数组，在每一次分区的时候直接在原数组上交换元素，将小于基准数的元素挪到数组开头，以[<code>5,1,4,2,3]</code>为例：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17148debd6e97be5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>我们定义一个pos指针, 标识等待置换的元素的位置, 然后逐一遍历数组元素, 遇到比基准数小的就和arr[pos]交换位置, 然后pos++<br>代码实现：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr, left, right</span>) &#123;          <span class="hljs-comment">//这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置</span>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> pos = left - <span class="hljs-number">1</span>                      <span class="hljs-comment">//pos即“被置换的位置”，第一趟为-1</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;    <span class="hljs-comment">//循环遍历数组，置换元素</span>            <span class="hljs-keyword">let</span> pivot = arr[right]              <span class="hljs-comment">//选取数组最后一位作为基准数，</span>            <span class="hljs-keyword">if</span>(arr[i] &lt;= pivot) &#123;               <span class="hljs-comment">//若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环</span>                pos++                <span class="hljs-keyword">let</span> temp = arr[pos]                arr[pos] = arr[i]                arr[i] = temp            &#125;        &#125;        <span class="hljs-comment">//一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组</span>        <span class="hljs-title function_">quickSort</span>(arr, left, pos - <span class="hljs-number">1</span>)                <span class="hljs-title function_">quickSort</span>(arr, pos + <span class="hljs-number">1</span>, right)    &#125;    <span class="hljs-keyword">return</span> arr      <span class="hljs-comment">//数组只包含1或0个元素时(即left&gt;=right)，递归终止</span>&#125;<span class="hljs-comment">//使用</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> end = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-title function_">quickSort</span>(arr, start, end)</code></pre></div><p>这个交换的过程还是需要一些时间理解消化的，详细分析可以看这篇：<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000017814119">js算法-快速排序(Quicksort)</a></p><h3 id="2-三路快排"><a href="#2-三路快排" class="headerlink" title="2. 三路快排"></a>2. 三路快排</h3><p>上边这个快排还谈不上优化，应当说是快排的纠正写法，其实有两个问题我们还能优化一下：</p><ol><li><strong>有序数组的情况</strong>：如果输入的数组是有序的，而取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空, 使时间复杂度退化到O(n2)</li><li><strong>大量重复数据的情况</strong>：例如输入的数据是<code>[1,2,2,2,2,3]</code>, 无论基准点取1、2还是3, 都会导致基准点两侧数组大小不平衡, 影响快排效率</li></ol><p>对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用<code>三路快排</code>的方式来优化，比方说对于上面的<code>[1,2,2,2,2,3]</code>，我们基准点取2，在分区的时候，将数组元素分为<code>小于2 | 等于2 | 大于2</code>三个区域，其中等于基准点的部分不再进入下一次排序, 这样就大大提高了快排效率</p><h2 id="5-手写归并排序"><a href="#5-手写归并排序" class="headerlink" title="5. 手写归并排序"></a>5. 手写归并排序</h2><blockquote><p>归并排序和快排的思路类似，都是递归分治，区别在于快排边分区边排序，而归并在分区完成后才会排序</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/2/1700388b88d9102c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr<span class="hljs-comment">//数组元素被划分到剩1个时，递归终止</span>    <span class="hljs-keyword">const</span> midIndex = arr.<span class="hljs-property">length</span>/<span class="hljs-number">2</span> | <span class="hljs-number">0</span>    <span class="hljs-keyword">const</span> leftArr = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, midIndex)    <span class="hljs-keyword">const</span> rightArr = arr.<span class="hljs-title function_">slice</span>(midIndex, arr.<span class="hljs-property">length</span>)    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(leftArr), <span class="hljs-title function_">mergeSort</span>(rightArr))<span class="hljs-comment">//先划分，后合并</span>&#125;<span class="hljs-comment">//合并</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">leftArr, rightArr</span>) &#123;    <span class="hljs-keyword">const</span> result = []    <span class="hljs-keyword">while</span>(leftArr.<span class="hljs-property">length</span> &amp;&amp; rightArr.<span class="hljs-property">length</span>) &#123;    leftArr[<span class="hljs-number">0</span>] &lt;= rightArr[<span class="hljs-number">0</span>] ? result.<span class="hljs-title function_">push</span>(leftArr.<span class="hljs-title function_">shift</span>()) : result.<span class="hljs-title function_">push</span>(rightArr.<span class="hljs-title function_">shift</span>())    &#125;    <span class="hljs-keyword">while</span>(leftArr.<span class="hljs-property">length</span>) result.<span class="hljs-title function_">push</span>(leftArr.<span class="hljs-title function_">shift</span>())    <span class="hljs-keyword">while</span>(rightArr.<span class="hljs-property">length</span>) result.<span class="hljs-title function_">push</span>(rightArr.<span class="hljs-title function_">shift</span>())    <span class="hljs-keyword">return</span> result&#125;</code></pre></div><h2 id="6-手写堆排序"><a href="#6-手写堆排序" class="headerlink" title="6. 手写堆排序"></a>6. 手写堆排序</h2><blockquote><p>堆是一棵特殊的树, 只要满足这棵树是完全二叉树和堆中每一个节点的值都大于或小于其左右孩子节点这两个条件, 那么就是一个堆, 根据堆中每一个节点的值都大于或小于其左右孩子节点, 又分为大根堆和小根堆</p></blockquote><p><strong>堆排序的流程：</strong></p><ol><li><p>初始化大(小)根堆，此时根节点为最大(小)值，将根节点与最后一个节点(数组最后一个元素)交换</p></li><li><p>除开最后一个节点，重新调整大(小)根堆，使根节点为最大(小)值</p></li><li><p>重复步骤二，直到堆中元素剩一个，排序完成</p></li></ol><p>以<code>[1,5,4,2,3</code>]为例构筑大根堆：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17148e2325d08c76~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 堆排序</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapSort</span> = array =&gt; &#123;        <span class="hljs-comment">// 我们用数组来储存这个大根堆,数组就是堆本身</span><span class="hljs-comment">// 初始化大顶堆，从第一个非叶子结点开始</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(array.<span class="hljs-property">length</span> / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-title function_">heapify</span>(array, i, array.<span class="hljs-property">length</span>);&#125;<span class="hljs-comment">// 排序，每一次 for 循环找出一个当前最大值，数组长度减一</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>); i &gt; <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">// 根节点与最后一个节点交换</span><span class="hljs-title function_">swap</span>(array, <span class="hljs-number">0</span>, i);<span class="hljs-comment">// 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可</span><span class="hljs-title function_">heapify</span>(array, <span class="hljs-number">0</span>, i);&#125;<span class="hljs-keyword">return</span> array;&#125;;<span class="hljs-comment">// 交换两个节点</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">array, i, j</span>) =&gt; &#123;<span class="hljs-keyword">let</span> temp = array[i];array[i] = array[j];array[j] = temp;&#125;;<span class="hljs-comment">// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：</span><span class="hljs-comment">// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的</span><span class="hljs-comment">// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。</span><span class="hljs-comment">// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点</span><span class="hljs-comment">// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">array, i, length</span>) =&gt; &#123;<span class="hljs-keyword">let</span> temp = array[i]; <span class="hljs-comment">// 当前父节点</span><span class="hljs-comment">// j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; j &lt; length; j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>) &#123;temp = array[i]; <span class="hljs-comment">// 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置</span><span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; length &amp;&amp; array[j] &lt; array[j + <span class="hljs-number">1</span>]) &#123;j++; <span class="hljs-comment">// 找到两个孩子中较大的一个，再与父节点比较</span>&#125;<span class="hljs-keyword">if</span> (temp &lt; array[j]) &#123;<span class="hljs-title function_">swap</span>(array, i, j); <span class="hljs-comment">// 如果父节点小于子节点:交换；否则跳出</span>i = j; <span class="hljs-comment">// 交换后，temp 的下标变为 j</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><blockquote><p>参考资料: <a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/90bf2dcd6a7b">JS实现堆排序</a></p></blockquote><h2 id="7-归并、快排、堆排有何区别"><a href="#7-归并、快排、堆排有何区别" class="headerlink" title="7. 归并、快排、堆排有何区别"></a>7. 归并、快排、堆排有何区别</h2><table><thead><tr><th>排序</th><th>时间复杂度(最好情况)</th><th>时间复杂度(最坏情况)</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)~O(n)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><p>其实从表格中我们可以看到，就时间复杂度而言，快排并没有很大优势，然而为什么快排会成为最常用的排序手段，这是因为时间复杂度只能说明<code>随着数据量的增加，算法时间代价增长的趋势</code>，并不直接代表实际执行时间，实际运行时间还包括了很多常数参数的差别，此外在面对不同类型数据(比如有序数据、大量重复数据)时，表现也不同，综合来说，快排的时间效率是最高的<br>在实际运用中, 并不只使用一种排序手段, 例如V8的<code>Array.sort()</code>就采取了<strong>当 n&lt;&#x3D;10 时, 采用插入排序, 当 n&gt;10 时，采用三路快排</strong>的排序策略<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ffee2595a85c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式有许多种，这里挑出几个常用的：</p><table><thead><tr><th>设计模式</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>单例模式</td><td>一个类只能构造出唯一实例</td><td>Redux&#x2F;Vuex的store</td></tr><tr><td>工厂模式</td><td>对创建对象逻辑的封装</td><td>jQuery的$(selector)</td></tr><tr><td>观察者模式</td><td>当一个对象被修改时，会自动通知它的依赖对象</td><td>Redux的subscribe、Vue的双向绑定</td></tr><tr><td>装饰器模式</td><td>对类的包装，动态地拓展类的功能</td><td>React高阶组件、ES7 装饰器</td></tr><tr><td>适配器模式</td><td>兼容新旧接口，对类的包装</td><td>封装旧API</td></tr><tr><td>代理模式</td><td>控制对象的访问</td><td>事件代理、ES6的Proxy</td></tr></tbody></table><h2 id="1-介绍一下单一职责原则和开放封闭原则"><a href="#1-介绍一下单一职责原则和开放封闭原则" class="headerlink" title="1. 介绍一下单一职责原则和开放封闭原则"></a>1. 介绍一下单一职责原则和开放封闭原则</h2><ol><li><p>单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p></li><li><p>开放封闭原则：核心的思想是软件实体（类、模块、函数等）是可扩展的、但不可修改的。也就是说,对扩展是开放的,而对修改是封闭的。</p></li></ol><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><p>单例模式即一个类只能构造出唯一实例，单例模式的意义在于<strong>共享、唯一</strong>，<code>Redux/Vuex</code>中的<code>store</code>、<code>JQ</code>的<code>$</code>或者业务场景中的购物车、登录框都是单例模式的应用</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLogin</span> &#123; <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,password</span>)&#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name <span class="hljs-variable language_">this</span>.<span class="hljs-property">password</span> = password &#125; <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params">name,password</span>)&#123; <span class="hljs-comment">//判断对象是否已经被创建,若创建则返回旧对象</span> <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>)<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLogin</span>(name,password) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> &#125;&#125;<span class="hljs-keyword">let</span> obj1 = <span class="hljs-title class_">SingletonLogin</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-string">&#x27;CXK&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>)<span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">SingletonLogin</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-string">&#x27;CXK&#x27;</span>,<span class="hljs-string">&#x27;321&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1===obj2)    <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1)           <span class="hljs-comment">// &#123;name:CXK,password:123&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2)           <span class="hljs-comment">// 输出的依然是&#123;name:CXK,password:123&#125;</span></code></pre></div><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><p>工厂模式即对创建对象逻辑的封装，或者可以简单理解为对<code>new</code>的封装，这种封装就像创建对象的工厂，故名工厂模式。工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如<code>React.createElement()</code>、<code>Vue.component()</code>都是工厂模式的实现。工厂模式有多种：<code>简单工厂模式</code>、<code>工厂方法模式</code>、<code>抽象工厂模式</code>，这里只以简单工厂模式为例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, auth</span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name <span class="hljs-variable language_">this</span>.<span class="hljs-property">auth</span> = auth &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFactory</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">name, auth</span>) &#123;    <span class="hljs-comment">//工厂内部封装了创建对象的逻辑:</span>    <span class="hljs-comment">//权限为admin时,auth=1, 权限为user时, auth为2</span>    <span class="hljs-comment">//使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户</span>    <span class="hljs-keyword">if</span>(auth === <span class="hljs-string">&#x27;admin&#x27;</span>)  <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name, <span class="hljs-number">1</span>)    <span class="hljs-keyword">if</span>(auth === <span class="hljs-string">&#x27;user&#x27;</span>)  <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name, <span class="hljs-number">2</span>)  &#125;&#125;<span class="hljs-keyword">const</span> admin = <span class="hljs-title class_">UserFactory</span>.<span class="hljs-title function_">createUser</span>(<span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>);<span class="hljs-keyword">const</span> user = <span class="hljs-title class_">UserFactory</span>.<span class="hljs-title function_">createUser</span>(<span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>);</code></pre></div><h2 id="4-观察者模式"><a href="#4-观察者模式" class="headerlink" title="4. 观察者模式"></a>4. 观察者模式</h2><p>观察者模式算是前端最常用的设计模式了，观察者模式概念很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。观察者模式被广泛用于监听事件的实现，有关观察者模式的详细应用，可以看我另一篇讲解<a href="https://juejin.cn/post/6844904036013965325#heading-3">Redux实现的文章</a></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;     <span class="hljs-title function_">constructor</span> (fn) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">update</span> = fn     &#125;&#125;<span class="hljs-comment">//被观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;             <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = []          <span class="hljs-comment">//观察者队列    </span> &#125;     <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123;               <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer)<span class="hljs-comment">//往观察者队列添加观察者    </span> &#125;     <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;                       <span class="hljs-comment">//通知所有观察者,实际上是把观察者的update()都执行了一遍       </span>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> &#123;                 observer.<span class="hljs-title function_">update</span>()            <span class="hljs-comment">//依次取出观察者,并执行观察者的update方法        </span>     &#125;)     &#125;&#125;<span class="hljs-keyword">var</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>()       <span class="hljs-comment">//被观察者</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">update</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;被观察者发出通知&#x27;</span>)&#125;  <span class="hljs-comment">//收到广播时要执行的方法</span><span class="hljs-keyword">var</span> ob1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(update)    <span class="hljs-comment">//观察者1</span><span class="hljs-keyword">var</span> ob2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(update)    <span class="hljs-comment">//观察者2</span>subject.<span class="hljs-title function_">addObserver</span>(ob1)          <span class="hljs-comment">//观察者1订阅subject的通知</span>subject.<span class="hljs-title function_">addObserver</span>(ob2)          <span class="hljs-comment">//观察者2订阅subject的通知</span>subject.<span class="hljs-title function_">notify</span>()                  <span class="hljs-comment">//发出广播,执行所有观察者的update方法</span></code></pre></div><p>有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心。</p><h2 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5. 装饰器模式"></a>5. 装饰器模式</h2><p>装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的<code>装饰器语法</code>以及React中的<code>高阶组件（HoC）</code>都是这一模式的实现。react-redux的<code>connect()</code>也运用了装饰器模式，这里以ES7的装饰器为例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">target</span>) &#123; target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span> target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">10</span>&#125;@info<span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> &#123;&#125;<span class="hljs-keyword">let</span> man = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>()man.<span class="hljs-property">name</span> <span class="hljs-comment">// 张三</span></code></pre></div><h2 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h2><p>适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123; <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;旧接口&#x27;</span> &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adaptee</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adaptee</span>()  &#125;  <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">let</span> info = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adaptee</span>.<span class="hljs-title function_">test</span>()      <span class="hljs-keyword">return</span> <span class="hljs-string">`适配<span class="hljs-subst">$&#123;info&#125;</span>`</span>  &#125;&#125;<span class="hljs-keyword">let</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">test</span>())</code></pre></div><h2 id="7-代理模式"><a href="#7-代理模式" class="headerlink" title="7. 代理模式"></a>7. 代理模式</h2><p>代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。<code>事件代理</code>、<code>JQuery的$.proxy</code>、<code>ES6的proxy</code>都是这一模式的实现，下面以ES6的proxy为例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> idol = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;蔡x抻&#x27;</span>, <span class="hljs-attr">phone</span>: <span class="hljs-number">10086</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">1000000</span>  <span class="hljs-comment">//报价</span>&#125;<span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(idol, &#123;  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) &#123;    <span class="hljs-comment">//拦截明星电话的请求,只提供经纪人电话</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;经纪人电话:10010&#x27;</span>  &#125;,  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value</span>) &#123;    <span class="hljs-keyword">if</span>(key === <span class="hljs-string">&#x27;price&#x27;</span> ) &#123;      <span class="hljs-comment">//经纪人过滤资质</span>      <span class="hljs-keyword">if</span>(value &lt; target.<span class="hljs-property">price</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;报价过低&#x27;</span>)      target.<span class="hljs-property">price</span> = value    &#125;  &#125;&#125;)agent.<span class="hljs-property">phone</span>        <span class="hljs-comment">//经纪人电话:10010</span>agent.<span class="hljs-property">price</span> = <span class="hljs-number">100</span>  <span class="hljs-comment">//Uncaught Error: 报价过低</span></code></pre></div><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/171465b92f6ded5e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h1><h2 id="1-说说HTML5在标签、属性、存储、API上的新特性"><a href="#1-说说HTML5在标签、属性、存储、API上的新特性" class="headerlink" title="1. 说说HTML5在标签、属性、存储、API上的新特性"></a>1. 说说HTML5在标签、属性、存储、API上的新特性</h2><p>标签：新增语义化标签（<code>aside / figure / section / header / footer / nav</code>等），增加多媒体标签<code>video</code>和<code>audio</code>，使得样式和结构更加分离<br>属性：增强表单，主要是增强了<code>input</code>的type属性；<code>meta</code>增加charset以设置字符集；<code>script</code>增加async以异步加载脚本<br>存储：增加<code>localStorage</code>、<code>sessionStorage</code>和<code>indexedDB</code>，引入了<code>application cache</code>对web和应用进行缓存<br>API：增加<code>拖放API</code>、<code>地理定位</code>、<code>SVG绘图</code>、<code>canvas绘图</code>、<code>Web Worker</code>、<code>WebSocket</code></p><h2 id="2-doctype的作用是什么？"><a href="#2-doctype的作用是什么？" class="headerlink" title="2. doctype的作用是什么？"></a>2. doctype的作用是什么？</h2><p>声明文档类型，告知浏览器用什么文档标准解析这个文档：</p><ul><li>怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式</li><li>标准模式：浏览器以W3C的标准解析文档</li></ul><h2 id="3-几种前端储存以及它们之间的区别"><a href="#3-几种前端储存以及它们之间的区别" class="headerlink" title="3. 几种前端储存以及它们之间的区别"></a>3. 几种前端储存以及它们之间的区别</h2><ul><li><strong>cookies</strong>： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好</li><li><strong>localStorage</strong>：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M</li><li><strong>sessionStorage</strong>：HTML5新特性，操作及大小同localStorage，和localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通</li><li><strong>IndexedDB</strong>： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制</li><li><strong>Web SQL</strong>：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差</li></ul><h2 id="4-href和src有什么区别"><a href="#4-href和src有什么区别" class="headerlink" title="4. href和src有什么区别"></a>4. href和src有什么区别</h2><p><code>href（hyperReference）</code>即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<code>&lt;link&gt;</code>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用<code>&lt;link&gt;</code>而不是<code>@import</code></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span></code></pre></div><p><code>src（resource）</code>即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="5-meta有哪些属性，作用是什么"><a href="#5-meta有哪些属性，作用是什么" class="headerlink" title="5. meta有哪些属性，作用是什么"></a>5. meta有哪些属性，作用是什么</h2><p>meta标签用于描述网页的<code>元信息</code>，如网站作者、描述、关键词，meta通过<code>name=xxx</code>和<code>content=xxx</code>的形式来定义信息，常用设置如下：</p><ul><li>charset：定义HTML文档的字符集</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span></code></pre></div><ul><li>http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新</li></ul><div class="code-wrapper"><pre><code class="hljs html">＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞</code></pre></div><ul><li>viewport：视口，用于控制页面宽高及缩放比例</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> </span><span class="hljs-tag">    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> </span><span class="hljs-tag">    <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span></span><span class="hljs-tag">&gt;</span></code></pre></div><h2 id="6-viewport有哪些参数，作用是什么"><a href="#6-viewport有哪些参数，作用是什么" class="headerlink" title="6. viewport有哪些参数，作用是什么"></a>6. viewport有哪些参数，作用是什么</h2><ul><li><p>width&#x2F;height，宽高，默认宽度980px</p></li><li><p>initial-scale，初始缩放比例，1~10</p></li><li><p>maximum-scale&#x2F;minimum-scale，允许用户缩放的最大&#x2F;小比例</p></li><li><p>user-scalable，用户是否可以缩放 (yes&#x2F;no)</p></li></ul><h2 id="7-http-equive属性的作用和参数"><a href="#7-http-equive属性的作用和参数" class="headerlink" title="7. http-equive属性的作用和参数"></a>7. http-equive属性的作用和参数</h2><ul><li><strong>expires</strong>：指定过期时间</li><li><strong>progma</strong>：设置no-cache可以禁止缓存</li><li><strong>refresh</strong>：定时刷新</li><li><strong>set-cookie</strong>：可以设置cookie</li><li><strong>X-UA-Compatible</strong>：使用浏览器版本</li><li><strong>apple-mobile-web-app-status-bar-style</strong>：针对WebApp全屏模式，隐藏状态栏&#x2F;设置状态栏颜色</li></ul><h1 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h1><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><blockquote><p>为什么要清除浮动：清除浮动是为了解决子元素浮动而导致父元素高度塌陷的问题</p></blockquote><h3 id="1-添加新元素"><a href="#1-添加新元素" class="headerlink" title="1. 添加新元素"></a>1. 添加新元素</h3><div class="code-wrapper"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;parent&quot;&gt;  &lt;<span class="hljs-selector-tag">div</span> class=&quot;child&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;  &lt;!-- 添加一个空元素，利用css提供的<span class="hljs-attribute">clear</span>:both清除浮动 --&gt;  &lt;div style=<span class="hljs-string">&quot;clear: both&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></div><h3 id="2-使用伪元素"><a href="#2-使用伪元素" class="headerlink" title="2. 使用伪元素"></a>2. 使用伪元素</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 对父元素添加伪元素 */</span><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">clear</span>:both;&#125;</code></pre></div><h3 id="3-触发父元素BFC"><a href="#3-触发父元素BFC" class="headerlink" title="3. 触发父元素BFC"></a>3. 触发父元素BFC</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 触发父元素BFC */</span><span class="hljs-selector-class">.parent</span> &#123;  <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-comment">/* float: left; */</span>  <span class="hljs-comment">/* position: absolute; */</span>  <span class="hljs-comment">/* display: inline-block */</span>  <span class="hljs-comment">/* 以上属性均可触发BFC */</span>&#125;</code></pre></div><h2 id="介绍一下flex布局"><a href="#介绍一下flex布局" class="headerlink" title="介绍一下flex布局"></a>介绍一下flex布局</h2><p>这一小节也不应该从“flex是什么”开始讲，主轴、侧轴这些概念相信用过flex布局都知道，所以我们直接flex的几个属性讲起：</p><h3 id="容器属性（使用在flex布局容器上的属性）"><a href="#容器属性（使用在flex布局容器上的属性）" class="headerlink" title="容器属性（使用在flex布局容器上的属性）"></a>容器属性（使用在flex布局容器上的属性）</h3><ul><li><strong>justify-content</strong>：定义了子元素在主轴(横轴)上的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">justify-content</span>: center | flex-start | flex-end | space-between | space-around;    <span class="hljs-comment">/* 主轴对齐方式：居中 | 左对齐(默认值) | 右对齐 | 两端对齐(子元素间边距相等) | 周围对齐(每个子元素两侧margin相等） */</span>&#125;</code></pre></div><ul><li><strong>align-items</strong>：定义了定义项目在交叉轴(竖轴)上对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">align-items</span>: center | flex-start | flex-end | baseline | stretch;    <span class="hljs-comment">/* 侧轴对齐方式：居中 | 上对齐 | 下对齐 | 项目的第一行文字的基线对齐 | 如果子元素未设置高度，将占满整个容器的高度（默认值） */</span>&#125;</code></pre></div><ul><li><strong>flex-direction</strong>：主轴(横轴)方向</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">.<span class="hljs-property">container</span> &#123;    flex-<span class="hljs-attr">direction</span>: row | row-reverse | column | column-reverse;    <span class="hljs-comment">/* 主轴方向：水平由左至右排列（默认值） | 水平由右向左 | 垂直由上至下 | 垂直由下至上 */</span>&#125;</code></pre></div><ul><li><strong>flex-wrap</strong>：换行方式</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;    <span class="hljs-comment">/* 换行方式：不换行（默认值） | 换行 | 反向换行 */</span>&#125;</code></pre></div><ul><li><strong>flex-flow</strong>：flex-flow属性是flex-direction属性和flex-wrap的简写</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;    <span class="hljs-comment">/* 默认值：row nowrap */</span>&#125;</code></pre></div><ul><li><strong>align-content</strong>：定义多根轴线的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">align-content</span>: center | flex-start | flex-end | space-between | space-around | stretch;    <span class="hljs-comment">/* 默认值：与交叉轴的中点对齐 | 与交叉轴的起点对齐 | 与交叉轴的终点对齐 | 与交叉轴两端对齐 | 每根轴线两侧的间隔都相等 | （默认值）：轴线占满整个交叉轴 */</span>&#125;</code></pre></div><h3 id="项目属性（使用在容器内子元素上的属性）"><a href="#项目属性（使用在容器内子元素上的属性）" class="headerlink" title="项目属性（使用在容器内子元素上的属性）"></a>项目属性（使用在容器内子元素上的属性）</h3><ul><li><strong>flex-grow</strong>：定义项目的放大比例，默认为0，即使有剩余空间也不放大。如果所有子元素flex-grow为1，那么将等分剩余空间，如果某个子元素flex-grow为2，那么这个子元素将占据2倍的剩余空间</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></div><ul><li><strong>flex-shrink</strong>：定义项目的缩小比例，默认为1，即如果空间不足，子元素将缩小。如果所有子元素flex-shrink都为1，某个子元素flex-shrink为0，那么该子元素将不缩小</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></div><p><strong>flex-basis</strong>：定义在分配多余空间之前，项目占据的主轴空间，默认auto，即子元素本来的大小，如果设定为一个固定的值，那么子元素将占据固定空间</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><ul><li><strong>flex</strong>：flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，即有剩余空间不放大，剩余空间不够将缩小，子元素占据自身大小</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]&#125;</code></pre></div><p>flex有两个快捷值：<code>auto</code>和<code>none</code>，分别代表<code>1 1 auto</code>（有剩余空间则平均分配，空间不够将等比缩小，子元素占据空间等于自身大小）和<code>0 0 auto</code>（有剩余空间也不分配，空间不够也不缩小，子元素占据空间等于自身大小）</p><ul><li><strong>order</strong>：定义项目的排列顺序。数值越小，排列越靠前，默认为0</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></div><ul><li><strong>align-self</strong>：定义单个子元素的排列方式，例如align-items设置了center，使得所有子元素居中对齐，那么可以通过给某个子元素设置align-self来单独设置子元素的排序方式</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>参考资料：<a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰Flex布局</a></p><h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC全称 Block Formatting Context 即块级格式上下文，简单的说，BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界<br>如何触发BFC</p><ul><li><code>float</code>不为 none</li><li><code>overflow</code>的值不为 visible</li><li><code>position</code> 为 absolute 或 fixed</li><li><code>display</code>的值为 inline-block 或 table-cell 或 table-caption 或 grid</li></ul><h2 id="BFC的渲染规则是什么"><a href="#BFC的渲染规则是什么" class="headerlink" title="BFC的渲染规则是什么"></a>BFC的渲染规则是什么</h2><ul><li><p>BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界</p></li><li><p>计算BFC的高度时，浮动子元素也参与计算（即内部有浮动元素时也不会发生高度塌陷）</p></li><li><p>BFC的区域不会与float的元素区域重叠</p></li><li><p>BFC内部的元素会在垂直方向上放置</p></li><li><p>BFC内部两个相邻元素的margin会发生重叠</p></li></ul><h2 id="BFC的应用场景"><a href="#BFC的应用场景" class="headerlink" title="BFC的应用场景"></a>BFC的应用场景</h2><ul><li><strong>清除浮动</strong>：BFC内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷</li><li><strong>避免某元素被浮动元素覆盖</strong>：BFC的区域不会与浮动元素的区域重叠</li><li><strong>阻止外边距重叠</strong>：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e0acba58457f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>原文链接：<a href="https://juejin.cn/post/6844904116552990727">2万字 | 前端基础拾遗90问</a> </p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局教程</title>
    <link href="/blog/flex-layout.html"/>
    <url>/blog/flex-layout.html</url>
    
    <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。</p><p><a href="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif"><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="img"></a></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>行内元素也可以使用 Flex 布局。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<span class="hljs-attribute">display</span>: inline-flex;&#125;</code></pre></div><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123; <span class="hljs-attribute">display</span>: -webkit-flex; <span class="hljs-comment">/* Safari */</span> <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</code></pre></div><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre></div><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p><a href="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png"><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></a></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]&#125;</code></pre></div><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><p>原文：阮一峰的博客 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二次封装 Axios</title>
    <link href="/blog/second-axios.html"/>
    <url>/blog/second-axios.html</url>
    
    <content type="html"><![CDATA[<p><strong>安装 axios</strong></p><div class="code-wrapper"><pre><code class="hljs bash">npm install axios --save</code></pre></div><p>安装成功后就可以在项目中使用了，<a href="https://link.juejin.cn/?target=https://github.com/axios/axios">具体使用方法可以查看 github</a>，接下来我就粘贴一下我个人的操作方法。 先在 src 目录下创建一个 utils 目录，再创建一个 https.js 文件，里面的编写如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//引入 axios</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span>;<span class="hljs-keyword">const</span> http = axios.<span class="hljs-title function_">create</span>(&#123;  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-number">50000</span>&#125;)<span class="hljs-comment">// 数据请求拦截</span>http.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> config;&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);<span class="hljs-comment">// 返回响应数据拦截</span>http.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span>;  <span class="hljs-comment">// 状态码为 2xx 范围时都会调用该函数，处理响应数据</span>  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;    <span class="hljs-keyword">const</span> code = data.<span class="hljs-property">code</span>;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(data);  &#125;&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;    <span class="hljs-comment">// 状态码超过 2xx 范围时都会调用该函数，处理错误响应</span>    <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:        <span class="hljs-title class_">ElMessage</span>(&#123;          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,          <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请求路径找不到！&#x27;</span>,          <span class="hljs-attr">showClose</span>: <span class="hljs-literal">true</span>        &#125;);        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-number">502</span>:        <span class="hljs-title class_">ElMessage</span>(&#123;          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,          <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;服务器内部报错！&#x27;</span>,          <span class="hljs-attr">showClose</span>: <span class="hljs-literal">true</span>        &#125;);        <span class="hljs-keyword">break</span>;      <span class="hljs-attr">default</span>:        <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);<span class="hljs-comment">//这是一位大佬指点的方法，更加简单</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http;<span class="hljs-comment">// 这是我原来的写法。</span><span class="hljs-comment">// post 请求方法</span><span class="hljs-comment">// export const post = (url, params) =&gt; &#123;</span><span class="hljs-comment">//  return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//    http.post(url, params).then(res =&gt; &#123;</span><span class="hljs-comment">//      resolve(res);</span><span class="hljs-comment">//    &#125;).catch(error =&gt; &#123;</span><span class="hljs-comment">//      reject(error);</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">//  &#125;);</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">// get 请求方法</span><span class="hljs-comment">//export const get = (url) =&gt; &#123;</span><span class="hljs-comment">//  return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//    http.get(url).then(res =&gt; &#123;</span><span class="hljs-comment">//      resolve(res);</span><span class="hljs-comment">//    &#125;).catch(error =&gt; &#123;</span><span class="hljs-comment">//      reject(error);</span><span class="hljs-comment">//    &#125;)</span><span class="hljs-comment">//  &#125;);</span><span class="hljs-comment">//&#125;</span><span class="hljs-variable constant_">JS</span></code></pre></div><p>编写完成后，这个 axios 就已经完成了简单的二次封装。封装后就开始引入使用了，我这里是把所有的请求放到了一个 js 文件里面，在 <strong>src</strong> 目录创建一个 <strong>api</strong> 目录，再创建一个 index.js 文件，</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 把封装好的 axios 引入</span><span class="hljs-comment">//import &#123; post, get &#125; from &#x27;../utils/https&#x27;;</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/https&#x27;</span>;<span class="hljs-comment">// 创建一个业务接口对象</span><span class="hljs-keyword">const</span> test = &#123;  <span class="hljs-title function_">query</span>(<span class="hljs-params">params</span>) &#123;    <span class="hljs-keyword">return</span> http.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/url&#x27;</span>, params);  &#125;,  <span class="hljs-title function_">test_get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> http.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/url&#x27;</span>)  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; test &#125;<span class="hljs-variable constant_">JS</span></code></pre></div><p>然后就可以在需要调用接口的组件中使用了，我习惯了在 main.js 里面进行全局注册。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 导入共用 api 文件import api from <span class="hljs-string">&#x27;./api/index&#x27;</span>......<span class="hljs-regexp">//</span> 我这里用的是 provide inject 这个组件通信的方法app.provide(<span class="hljs-string">&#x27;$api&#x27;</span>, api);<span class="hljs-regexp">//</span>也可以使用 app.config.globalProperties.<span class="hljs-variable">$api</span> = api; (vue3) -- 挂载到原型链上<span class="hljs-regexp">//</span> Vue.prototype.<span class="hljs-variable">$api</span> = api; (vue2.x)</code></pre></div><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script setup&gt;<span class="hljs-keyword">import</span> &#123; getCurrentInstance, inject, ref, useAttrs, useSlots &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-comment">// provide 对应的使用方法</span><span class="hljs-keyword">const</span> $api = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;$api&#x27;</span>)<span class="hljs-comment">// app.config.globalProperties </span><span class="hljs-comment">// const &#123; proxy &#125; = getCurrentInstance();</span><span class="hljs-comment">// const $api = proxy.$api;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;    $api.<span class="hljs-property">test</span>.<span class="hljs-title function_">query</span>(params).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);    &#125;)&#125;&lt;/script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEO 优化、前端优化</title>
    <link href="/blog/seo-optimize.html"/>
    <url>/blog/seo-optimize.html</url>
    
    <content type="html"><![CDATA[<h2 id="vue优化"><a href="#vue优化" class="headerlink" title="vue优化"></a>vue优化</h2><ol><li>Vue-Router路由懒加载：Vue异步组件、Webpack的require.ensure()、ES6的import、</li><li>按需加载UI库</li><li>如果首屏为登录页，可以做成多入口</li><li>页面使用骨架屏Skeleton Screen</li><li>服务端渲染SSR（将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序）</li></ol><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ol><li>减少 HTTP 请求数量</li><li>利用浏览器缓存，减小<code>cookie</code>大小，尽量用<code>localStorage</code>代替</li><li>CDN加速，托管静态文件</li><li>开启 Gzip 压缩：Nginx的gzip缓存压缩、Webpack开启gzip压缩</li></ol><h2 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h2><ol><li>节流、防抖</li><li>动态加载、分页加载（大数据渲染）</li><li>图片懒加载（data-src）减少占用网络带宽</li><li>使用闭包时，在函数结尾手动删除不需要的局部变量，尤其在缓存dom节点的情况下</li><li>异步加载js，async解析dom树同时加载js，加载完暂停解析执行js、defer解析dom树同时加载js，解析完执行js</li></ol><h2 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h2><p>不使用css表达式</p><p>减少回流（重排）</p><p>避免使用css文件嵌套过深</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>突出重要内容—合理的设计<code>title</code>、<code>description</code>和<code>keywords</code></p><p>语义化书写HTML代码，符合W3C标准</p><p>图片<code>img</code>标签添加<code>alt</code>和<code>title</code>属性</p><p>链接<code>&lt;a&gt;</code>页内标签添加<code>title</code>属性</p><p>使用h1标签自带权重</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seo优化</tag>
      
      <tag>vue优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式到底是什么？</title>
    <link href="/blog/regexp-course.html"/>
    <url>/blog/regexp-course.html</url>
    
    <content type="html"><![CDATA[<p>正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表达式的时候，都会打开谷歌或百度直接搜索然后拷贝粘贴。当下一次再遇到相同问题的时候，同样的场景又再来一遍。作为一门用途很广的技术，我相信深入理解正则表达式并能融会贯通是值得的。所以，希望这篇文章能帮助大家理清思路，搞懂正则表达式各种符号之间的内在联系，形成知识体系，当下次再遇到正则表达式的时候可以不借助搜索引擎，自己解决。</p><h1 id="正则表达式到底是什么？"><a href="#正则表达式到底是什么？" class="headerlink" title="正则表达式到底是什么？"></a>正则表达式到底是什么？</h1><p>正则表达式(Regular Expression)其实就是一门工具，<strong>目的</strong>是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种<strong>用来描述规则的表达式</strong>。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用<a href="https://link.juejin.cn/?target=https://regexper.com/">regexper.com</a>这个工具很好地可视化自己写的正则表达式:</p><p>如<code>/\d\w+/</code>这个正则生成的状态机图:</p><p><a href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></a></p><p>对于具体的算法实现，大家如果感兴趣可以阅读《算法导论》。</p><h1 id="从字符出发"><a href="#从字符出发" class="headerlink" title="从字符出发"></a>从字符出发</h1><p>我们学习一个系统化的知识，一定要从其基础构成来了解。正则表达式的基本<strong>组成元素</strong>可以分为：<strong>字符和元字符</strong>。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。接下来，我们就来从这些基本单位出发，来学习一下如何构建正则表达式。</p><h2 id="单个字符"><a href="#单个字符" class="headerlink" title="单个字符"></a>单个字符</h2><p>最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在’apple’这个单词里找到‘a’这个字符，就直接用<code>/a/</code>这个正则就可以了。</p><p>但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**<code>\</code>**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：</p><p>我想匹配<code>*</code>这个符号，由于<code>*</code>这个符号本身是个特殊字符，所以我要利用转义元字符<code>\</code>来让它失去其本来的含义：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/\*/</span>AWK</code></pre></div><p>如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：</p><table><thead><tr><th>特殊字符</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>换行符</td><td>\n</td><td><strong>n</strong>ew line</td></tr><tr><td>换页符</td><td>\f</td><td><strong>f</strong>orm feed</td></tr><tr><td>回车符</td><td>\r</td><td><strong>r</strong>eturn</td></tr><tr><td>空白符</td><td>\s</td><td><strong>s</strong>pace</td></tr><tr><td>制表符</td><td>\t</td><td><strong>t</strong>ab</td></tr><tr><td>垂直制表符</td><td>\v</td><td><strong>v</strong>ertical tab</td></tr><tr><td>回退符</td><td>[\b]</td><td><strong>b</strong>ackspace,之所以使用[]符号是避免和\b重复</td></tr></tbody></table><h2 id="多个字符"><a href="#多个字符" class="headerlink" title="多个字符"></a>多个字符</h2><p>单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。</p><p>在正则表达式里，集合的定义方式是使用中括号<code>[</code>和<code>]</code>。如<code>/[123]/</code>这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符<code>-</code>就可以用来表示区间范围，利用<code>/[0-9]/</code>就能匹配所有的数字, <code>/[a-z]/</code>则可以匹配所有的英文小写字母。</p><p>即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:</p><table><thead><tr><th>匹配区间</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>除了换行符之外的任何字符</td><td>.</td><td>句号,除了句子结束符</td></tr><tr><td>单个数字, [0-9]</td><td>\d</td><td><strong>d</strong>igit</td></tr><tr><td>除了[0-9]</td><td>\D</td><td><strong>not</strong> <strong>d</strong>igit</td></tr><tr><td>包括下划线在内的单个字符，[A-Za-z0-9_]</td><td>\w</td><td><strong>w</strong>ord</td></tr><tr><td>非单字字符</td><td>\W</td><td><strong>not</strong> <strong>w</strong>ord</td></tr><tr><td>匹配空白字符,包括空格、制表符、换页符和换行符</td><td>\s</td><td><strong>s</strong>pace</td></tr><tr><td>匹配非空白字符</td><td>\S</td><td><strong>not</strong> <strong>s</strong>pace</td></tr></tbody></table><h1 id="循环与重复"><a href="#循环与重复" class="headerlink" title="循环与重复"></a>循环与重复</h1><p>一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。</p><h2 id="0-1"><a href="#0-1" class="headerlink" title="0 | 1"></a>0 | 1</h2><p>元字符<code>?</code>代表了匹配一个字符或0个字符。设想一下，如果你要匹配<code>color</code>和<code>colour</code>这两个单词，就需要同时保证<code>u</code>这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：<code>/colou?r/</code>。</p><h2 id="gt-x3D-0"><a href="#gt-x3D-0" class="headerlink" title="&gt;&#x3D; 0"></a>&gt;&#x3D; 0</h2><p>元字符<code>*</code>用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。</p><h2 id="gt-x3D-1"><a href="#gt-x3D-1" class="headerlink" title="&gt;&#x3D; 1"></a>&gt;&#x3D; 1</h2><p>元字符<code>+</code>适用于要匹配同个字符出现1次或多次的情况。</p><h2 id="特定次数"><a href="#特定次数" class="headerlink" title="特定次数"></a>特定次数</h2><p>在某些情况下，我们需要匹配特定的重复次数，元字符<code>&#123;</code>和<code>&#125;</code>用来给重复匹配设置精确的区间范围。如’a’我想匹配3次,那么我就使用<code>/a&#123;3&#125;/</code>这个正则，或者说’a’我想匹配至少两次就是用<code>/a&#123;2,&#125;/</code>这个正则。</p><p>以下是完整的语法：</p><div class="code-wrapper"><pre><code class="hljs llvm">- &#123;<span class="hljs-keyword">x</span>&#125;: <span class="hljs-keyword">x</span>次- &#123;<span class="hljs-keyword">min</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">max</span>&#125;： 介于<span class="hljs-keyword">min</span>次到<span class="hljs-keyword">max</span>次之间- &#123;<span class="hljs-keyword">min</span><span class="hljs-punctuation">,</span> &#125;: 至少<span class="hljs-keyword">min</span>次- &#123;<span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">max</span>&#125;： 至多<span class="hljs-keyword">max</span>次ARDUINO</code></pre></div><p>由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。</p><table><thead><tr><th>匹配规则</th><th>元字符</th><th>联想方式</th></tr></thead><tbody><tr><td>0次或1次</td><td>?</td><td>且<strong>问</strong>,此事<strong>有</strong>还<strong>无</strong></td></tr><tr><td>0次或无数次</td><td>*</td><td>宇宙洪荒,<strong>辰宿</strong>列张：宇宙伊始，从无到有，最后星宿布满星空</td></tr><tr><td>1次或无数次</td><td>+</td><td><strong>一加</strong>, +1</td></tr><tr><td>特定次数</td><td>{x}, {min, max}</td><td>可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界</td></tr></tbody></table><h1 id="位置边界"><a href="#位置边界" class="headerlink" title="位置边界"></a>位置边界</h1><p>上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。</p><h2 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h2><p>单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：</p><div class="code-wrapper"><pre><code class="hljs sql">The cat scattered his food <span class="hljs-keyword">all</span> <span class="hljs-keyword">over</span> the room.<span class="hljs-keyword">SQL</span></code></pre></div><p>我想找到<code>cat</code>这个单词，但是如果只是使用<code>/cat/</code>这个正则，就会同时匹配到<code>cat</code>和<code>scattered</code>这两处文本。这时候我们就需要使用边界正则表达式<code>\b</code>，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\w)和不能构成单词的字符(\W)中间的那个位置。</p><p>上面的例子改写成<code>/\bcat\b/</code>这样就能匹配到<code>cat</code>这个单词了。</p><h2 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h2><p>匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符<code>^</code>用来匹配字符串的开头。而元字符<code>$</code>用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配<code>I am scq000</code>这个句子：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> am scq000.<span class="hljs-selector-tag">I</span> am scq000.<span class="hljs-selector-tag">I</span> am scq000.CSS</code></pre></div><p>我们可以使用<code>/^I am scq000\.$/m</code>这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。</p><p>最后，总结一下：</p><table><thead><tr><th>边界和标志</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>单词边界</td><td>\b</td><td><strong>b</strong>oundary</td></tr><tr><td>非单词边界</td><td>\B</td><td><strong>not</strong> <strong>b</strong>oundary</td></tr><tr><td>字符串开头</td><td>^</td><td>小<strong>头尖尖</strong>那么大个</td></tr><tr><td>字符串结尾</td><td>$</td><td><strong>终结</strong>者，美国科幻电影，美元符$</td></tr><tr><td>多行模式</td><td>m标志</td><td><strong>m</strong>ultiple of lines</td></tr><tr><td>忽略大小写</td><td>i标志</td><td><strong>i</strong>gnore case, case-<strong>i</strong>nsensitive</td></tr><tr><td>全局模式</td><td>g标志</td><td><strong>g</strong>lobal</td></tr></tbody></table><h1 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h1><p>字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。</p><p>从简单到复杂的正则表达式演变通常要采用<strong>分组、回溯引用和逻辑处理</strong>的思想。利用这三种规则，可以推演出无限复杂的正则表达式。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>其中分组体现在：所有以<code>(</code>和<code>)</code>元字符所包含的正则表达式被分为一组，每一个分组都是一个<strong>子表达式</strong>，它也是构成高级正则表达式的基础。如果只是使用简单的<code>(regex)</code>匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。</p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像<code>\1</code>,<code>\2</code>,….,其中<code>\1</code>表示引用的第一个子表达式，<code>\2</code>表示引用的第二个子表达式，以此类推。而<code>\0</code>则表示整个表达式。</p><p>假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？</p><div class="code-wrapper"><pre><code class="hljs vim">Hello what what <span class="hljs-keyword">is</span> the <span class="hljs-keyword">first</span> thing, <span class="hljs-built_in">and</span> I <span class="hljs-keyword">am</span> <span class="hljs-keyword">am</span> scq000.CSHARP</code></pre></div><p>利用回溯引用，我们可以很容易地写出<code>\b(\w+)\s\1</code>这样的正则。</p><p>回溯引用在替换字符串中十分常用，语法上有些许区别，用<code>$1</code>,<code>$2</code>…来引用要被替换的字符串。下面以js代码作演示：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc abc 123&#x27;</span>;str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(ab)c/g</span>,<span class="hljs-string">&#x27;$1g&#x27;</span>);<span class="hljs-comment">// 得到结果 &#x27;abg abg 123&#x27;</span>JAVASCRIPT</code></pre></div><p>如果我们不想子表达式被引用，可以使用<strong>非捕获</strong>正则<code>(?:regex)</code>这样就可以避免浪费内存。</p><div class="code-wrapper"><pre><code class="hljs awk">var str = <span class="hljs-string">&#x27;scq000&#x27;</span>.str.replace(<span class="hljs-regexp">/(scq00)(?:0)/</span>, <span class="hljs-string">&#x27;$1,$2&#x27;</span>)<span class="hljs-regexp">//</span> 返回scq00,<span class="hljs-variable">$2</span><span class="hljs-regexp">//</span> 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为<span class="hljs-variable">$2</span>JAVASCRIPT</code></pre></div><p>有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。</p><h3 id="前向查找"><a href="#前向查找" class="headerlink" title="前向查找"></a>前向查找</h3><p>前向查找(lookahead)是用来限制后缀的。凡是以<code>(?=regex)</code>包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如<code>happy happily</code>这两个单词，我想获得以<code>happ</code>开头的副词，那么就可以使用<code>happ(?=ily)</code>来匹配。如果我想过滤所有以<code>happ</code>开头的副词，那么也可以采用<strong>负前向查找</strong>的正则<code>happ(?!ily)</code>，就会匹配到<code>happy</code>单词的<code>happ</code>前缀。</p><h3 id="后向查找"><a href="#后向查找" class="headerlink" title="后向查找"></a>后向查找</h3><p>介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： <code>apple</code>和<code>people</code>都包含<code>ple</code>这个后缀，那么如果我只想找到<code>apple</code>的<code>ple</code>，该怎么做呢？我们可以通过限制<code>app</code>这个前缀，就能唯一确定<code>ple</code>这个单词了。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/(?&lt;=app)ple/</span>RUBY</code></pre></div><p>其中<code>(?&lt;=regex)</code>的语法就是我们这里要介绍的后向查找。<code>regex</code>指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向<strong>后</strong>查找。另外一种限制匹配是利用<code>(?&lt;!regex)</code> 语法，这里称为<strong>负后向查找</strong>。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找<code>apple</code>的<code>ple</code>也可以这么写成<code>/(?&lt;!peo)ple</code>。</p><p>需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// 比如我想替换apple的ple为ply</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;apple people&#x27;</span>;str.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().join(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/elp(?=pa)/</span>, <span class="hljs-string">&#x27;ylp&#x27;</span>).<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().join(<span class="hljs-string">&#x27;&#x27;</span>);PERL</code></pre></div><blockquote><p>ps: 从es2018之后，chrome中的正则表达式也支持反向查找了。不过，在实际项目中还需要注意对旧浏览器的支持，以防线上出现Bug。详情请查看<a href="http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions">http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions</a></p></blockquote><p>最后回顾一下这部分内容：</p><table><thead><tr><th>回溯查找</th><th>正则</th><th>记忆方式</th></tr></thead><tbody><tr><td>引用</td><td>\0,\1,\2 和 $0, $1, $2</td><td>转义+数字</td></tr><tr><td>非捕获组</td><td>(?:)</td><td>引用表达式(()), 本身不被消费(?),引用(:)</td></tr><tr><td>前向查找</td><td>(?&#x3D;)</td><td>引用子表达式(())，本身不被消费(?), 正向的查找(&#x3D;)</td></tr><tr><td>前向负查找</td><td>(?!)</td><td>引用子表达式(())，本身不被消费(?), 负向的查找(!)</td></tr><tr><td>后向查找</td><td>(?&lt;&#x3D;)</td><td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，正的查找(&#x3D;)</td></tr><tr><td>后向负查找</td><td>(?&lt;!)</td><td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，负的查找(!)</td></tr></tbody></table><h2 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h2><p>计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。</p><p>在正则里面，默认的正则规则都是<strong>与</strong>的关系所以这里不讨论。</p><p>而<strong>非</strong>关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用<code>^</code>这个元字符。在这里要着重记忆一下：<strong>只有在<code>[</code>和<code>]</code>内部使用的<code>^</code>才表示非的关系</strong>。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式<code>(?!regex)</code>或后向负查找子表达式<code>(?&lt;!regex)</code>。</p><p>或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用<code>(a|b)</code>这样的子表达式。</p><table><thead><tr><th>逻辑关系</th><th>正则元字符</th></tr></thead><tbody><tr><td>与</td><td>无</td></tr><tr><td>非</td><td>[^regex]和!</td></tr><tr><td>或</td><td>|</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于正则来说，符号之抽象往往让很多程序员却步。针对不好记忆的特点，我通过分类和联想的方式努力让其变得有意义。我们先从一对一的单字符，再到多对多的子字符串介绍，然后通过分组、回溯引用和逻辑处理的方式来构建高级的正则表达式。</p><p>在最后，出个常用的正则面试题吧：请写出一个正则来处理数字千分位，如<code>12345</code>替换为<code>12,345</code>。请尝试自己推理演绎得出答案，而不是依靠搜索引擎:)。</p>]]></content>
    
    
    <categories>
      
      <category>regexp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖节流</title>
    <link href="/blog/debounce-throttle.html"/>
    <url>/blog/debounce-throttle.html</url>
    
    <content type="html"><![CDATA[<p>防抖和节流，这个在我们的前端生涯中，这两个名词肯定不陌生，甚至经常被人问起：</p><ul><li>两者有什么区别？</li><li>分别用于什么场景？ <strong>ps：这就是高频的面试题了吧！</strong></li></ul><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖是什么呢？</p><p>形象的的说就是：防止抖动（防抖函数内心独白：“你就抖动吧！等你不抖动了，我们在进行下一步”）</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>一个搜索输入框， 用户不停的进行输入（<strong>这个时候就是抖动的过程</strong>）， 等用户输入停止之后，再触发搜索。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">200</span></span>) &#123;  <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 如果这个函数已经被触发了</span>    <span class="hljs-keyword">if</span>(timer)&#123;      <span class="hljs-built_in">clearTimeout</span>(timer)    &#125;    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 透传 this和参数</span>      timer = <span class="hljs-number">0</span>    &#125;,delay)  &#125;&#125;</code></pre></div><p><a href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46181f1811fa4a99a1659c324c677014~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46181f1811fa4a99a1659c324c677014~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></a></p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流：节省交互沟通。</p><p>形象的的说就是：no！no！no！一个一个来，按照时间节奏来！插队禁止！</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><p>drag（拖动）事件或者 scroll（滚动） 期间触发某个毁掉，要设置一个时间间隔。这时候就<strong>不能使用防抖</strong>了，为什么呢？</p><p>防抖是拖拽或者滚动结束之后才返回回调，但是我是需要在过程中进行触发回调，但是又不需要那么的频繁；这时候就使用<strong>节流函数</strong>，每隔一定的时间进项触发就好了！</p><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 节流函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">200</span></span>) &#123;  <span class="hljs-keyword">let</span>  timer = <span class="hljs-number">0</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span>(timer)&#123;      <span class="hljs-keyword">return</span>    &#125;    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 透传 this和参数</span>      timer = <span class="hljs-number">0</span>    &#125;,delay)  &#125;&#125;</code></pre></div><p>咋一看，怎么和防抖函数好像怎么这么像？</p><p>区别仅仅在：</p><p>防抖：</p><div class="code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-keyword">if</span>(timer)&#123;  <span class="hljs-built_in">clearTimeout</span>(timer)&#125;</code></pre></div><p>节流：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(timer)&#123;  <span class="hljs-keyword">return</span>&#125;</code></pre></div><p>他们在定时器已经有任务的时候的操作的不同。在我们上面介绍了防抖和节流的概念之后，大家应该都懂了。</p><p>防抖函数在每一次都有内容后进行清除是为了保证当前执行的函数就是当前规定的时间内执行的最后一次操作</p><div class="code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-keyword">if</span>(timer)&#123;  <span class="hljs-built_in">clearTimeout</span>(timer)&#125;</code></pre></div><p>节流函数如此操作是为了保证，在规定的时间内只会执行一次这个操作，这就是两个函数从代码上看到的不同</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(timer)&#123;  <span class="hljs-keyword">return</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防抖</tag>
      
      <tag>节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扁平数组与JSON树结构互转</title>
    <link href="/blog/flat-structure-conversion-tree-structure.html"/>
    <url>/blog/flat-structure-conversion-tree-structure.html</url>
    
    <content type="html"><![CDATA[<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><h5 id="扁平数组"><a href="#扁平数组" class="headerlink" title="扁平数组"></a>扁平数组</h5><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张大大&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;项目经理&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小亮&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品leader&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;03&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小美&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UIleader&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老马&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术leader&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老王&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试leader&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;06&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老李&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;运维leader&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;07&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小丽&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品经理&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;08&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;大光&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品经理&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;09&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小高&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;03&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UI设计师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小刘&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前端工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小华&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;后端工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小李&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;后端工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小赵&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;14&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小强&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;15&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小涛&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;06&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;运维工程师&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span></code></pre></div><h5 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h5><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">[</span>  <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张大大&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;项目经理&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>      <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小亮&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品leader&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;07&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小丽&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品经理&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;08&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;大光&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;02&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;产品经理&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;03&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小美&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UIleader&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;09&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小高&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;03&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UI设计师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老马&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术leader&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小刘&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前端工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小华&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;后端工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小李&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;04&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;后端工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老王&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试leader&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小赵&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;14&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小强&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;05&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;06&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老李&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;运维leader&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>          <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;15&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小涛&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;pid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;06&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;运维工程师&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span></code></pre></div><h5 id="转换算法"><a href="#转换算法" class="headerlink" title="转换算法"></a>转换算法</h5><p><strong>「扁平数组」转「树形结构」</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">treeing</span> (arr) &#123;  <span class="hljs-keyword">let</span> tree = []  <span class="hljs-keyword">const</span> map = &#123;&#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;    <span class="hljs-comment">// 一个新的带children的结构</span>    <span class="hljs-keyword">let</span> newItem = map[item.<span class="hljs-property">id</span>] = &#123;      ...item,      <span class="hljs-attr">children</span>: []    &#125;    <span class="hljs-keyword">if</span> (map[item.<span class="hljs-property">pid</span>]) &#123; <span class="hljs-comment">// 父节点已存进map则在父节点的children添加新元素</span>      <span class="hljs-keyword">let</span> parent = map[item.<span class="hljs-property">pid</span>]      parent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(newItem)    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有父节点，在根节点添加父节点</span>      tree.<span class="hljs-title function_">push</span>(newItem)    &#125;  &#125;  <span class="hljs-keyword">return</span> tree&#125;</code></pre></div><p><strong>「树形结构」转「扁平数组」</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span> (tree, arr = []) &#123;  tree.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123;children, ...props&#125; = item    <span class="hljs-comment">// 添加除了children的属性</span>    arr.<span class="hljs-title function_">push</span>(props)    <span class="hljs-keyword">if</span> (children) &#123;      <span class="hljs-comment">// 递归将所有节点加入到结果集中</span>      <span class="hljs-title function_">flatten</span>(children, arr)    &#125;  &#125;)  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p><strong>菜单数据结构转换（扁平化数据和树形结构互转）</strong><br>数据格式如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> treeData = [  &#123;    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1&quot;</span>,    <span class="hljs-attr">children</span>: [      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-1&quot;</span> &#125;,      &#123;        <span class="hljs-attr">id</span>: <span class="hljs-number">5</span>,        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2&quot;</span>,        <span class="hljs-attr">children</span>: [          &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2-1&quot;</span> &#125;,          &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2-2&quot;</span> &#125;,        ],      &#125;,    ],  &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程2&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程3&quot;</span> &#125;,];<span class="hljs-keyword">const</span> flatData = [  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-1&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">5</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2-1&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">7</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程1-2-2&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程2&quot;</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<span class="hljs-attr">parent</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;课程3&quot;</span> &#125;,]</code></pre></div><p><strong>1.树形结构转扁平化</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TreeToFlat</span>(<span class="hljs-params">data</span>) &#123;   <span class="hljs-keyword">let</span> formatData = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) &#123;    formatData.<span class="hljs-title function_">push</span>(&#123;      <span class="hljs-attr">id</span>: data[i].<span class="hljs-property">id</span>,      <span class="hljs-attr">title</span>: data[i].<span class="hljs-property">title</span>,    &#125;)    <span class="hljs-keyword">if</span> (data[i].<span class="hljs-property">children</span>) &#123;      formatData = formatData.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">TreeToFlat</span>(data[i].<span class="hljs-property">children</span>));    &#125;  &#125;  <span class="hljs-keyword">return</span> formatData;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">TreeToFlat</span>(treeData),<span class="hljs-string">&#x27;输出为扁平化结构&#x27;</span>)</code></pre></div><p><strong>2.扁平化数据转为树形结构</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FlatToTree</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">const</span> map = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> &#123;    acc[val.<span class="hljs-property">id</span>] = val    <span class="hljs-keyword">return</span> acc  &#125;, &#123;&#125;)  <span class="hljs-keyword">const</span> tree = []  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">region</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (region.<span class="hljs-property">parent</span>) &#123;      <span class="hljs-keyword">const</span> parent = map[region.<span class="hljs-property">parent</span>]      <span class="hljs-keyword">if</span> (!parent.<span class="hljs-property">children</span>) &#123;        parent.<span class="hljs-property">children</span> = [region]      &#125;      <span class="hljs-keyword">else</span> &#123;        parent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(region)      &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;      tree.<span class="hljs-title function_">push</span>(region)    &#125;  &#125;)  <span class="hljs-keyword">return</span> &#123; tree &#125;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FlatToTree</span>(flatData),<span class="hljs-string">&#x27;输出为树形结构&#x27;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扁平数组</tag>
      
      <tag>树结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 文章写作</title>
    <link href="/blog/hexo-active.html"/>
    <url>/blog/hexo-active.html</url>
    
    <content type="html"><![CDATA[<h2 id="文章配置-文末有我一般配置"><a href="#文章配置-文末有我一般配置" class="headerlink" title="文章配置(文末有我一般配置)"></a>文章配置(文末有我一般配置)</h2><div class="code-wrapper"><pre><code class="hljs markdown">---title: 文章标题<span class="hljs-section">date: 2022/7/13 20:46:25</span><span class="hljs-section">---</span></code></pre></div><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>hide</code></td><td align="left">首页隐藏文章</td><td align="left">false</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs markdown">categories:<span class="hljs-bullet">-</span> 分类名称tags:<span class="hljs-bullet">-</span> 标签名称<span class="hljs-bullet">-</span> 标签名称2</code></pre></div><h4 id="便签"><a href="#便签" class="headerlink" title="便签"></a>便签</h4><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p>可选便签：</p><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>success</p>          </div><div class="note note-warning">            <p>success</p>          </div><div class="note note-info">            <p>success</p>          </div><div class="note note-light">            <p>success</p>          </div><h4 id="行内便签"><a href="#行内便签" class="headerlink" title="行内便签"></a>行内便签</h4><span class="label label-primary">你好</span><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% label primary @你好 %&#125;</code></pre></div><p>可选 label ：</p><span class="label label-primary">primary</span><span class="label label-default">default</span><span class="label label-info">info</span><span class="label label-success">success</span><span class="label label-warning">warning</span><span class="label label-danger">danger</span><p><code>你好</code> &#x3D;  <span class="label label-default">你好</span></p><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-code">`你好`</span> = &#123;% label default @你好 %&#125;</code></pre></div><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% btn url路径, 显示的文字, 鼠标悬停的文字 %&#125;</code></pre></div><a class="btn" href="#"  title="鼠标悬停的文字" target="_blank">显示的文字</a><h4 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h4><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% gi total n1-n2-... %&#125;  ![](<span class="hljs-link">url</span>)  ![](<span class="hljs-link">url</span>)  ![](<span class="hljs-link">url</span>)  ![](<span class="hljs-link">url</span>)  ![](<span class="hljs-link">url</span>)&#123;% endgi %&#125;</code></pre></div><p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><p>如下图为 <code>&#123;% gi 5 3-2 %&#125;</code> 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p><p><img src="https://hexo.fluid-dev.com/docs/assets/img/group_image.c1b58381.png" alt="组图"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><div class="code-wrapper"><pre><code class="hljs markdown">title: 标题date: 时间tags: [标签, 标签1]categories: [分类]author: 作者permalink: 永久链接.htmlhide: false</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
